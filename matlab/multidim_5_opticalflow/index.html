
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Optical Flow Computation</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-20">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Optical Flow Computation</h1>
         <introduction>
            <p>This numerical tour explores the computation of optical flow between two images. It is at the heart of video coding.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Loading Warped Images</a></li>
               <li><a href="#12">Optical Flow Computation with Regularization</a></li>
               <li><a href="#37">Optical Flow Computation with Block Matching</a></li>
               <li><a href="#54">Residual Computation</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a> and <a href="../toolbox_general.zip">general toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt> and <tt>toolbox_general</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
</pre><h2>Loading Warped Images<a name="8"></a></h2>
         <p>To evaluate the performance of optical flow computation, we compute a pair of image obtained by a smooth warping (small deformation),
            here a simple rotation.
         </p>
         <p>Original frame #1.</p><pre class="codeinput">n = 256;
name = <span class="string">'lena'</span>;
M1 = rescale( load_image(name,n) );
</pre><p>The second image <tt>M2</tt> is obtaind by rotating the first one.
         </p><pre class="codeinput"><span class="comment">% angle of rotation</span>
theta = .03 * pi/2;
<span class="comment">% original coordinates</span>
[Y,X] = meshgrid(1:n,1:n);
<span class="comment">% rotated coordinates</span>
X1 = (X-n/2)*cos(theta) + (Y-n/2)*sin(theta) + n/2;
Y1 =-(X-n/2)*sin(theta) + (Y-n/2)*cos(theta) + n/2;
<span class="comment">% boundary handling</span>
X1 = mod(X1-1,n)+1;
Y1 = mod(Y1-1,n)+1;
<span class="comment">% interpolation</span>
M2 = interp2(Y,X,M1,Y1,X1);
M2(isnan(M2)) = 0;
</pre><p>Display the two images.</p><pre class="codeinput">clf;
imageplot(M1, <span class="string">'Frame #1'</span>, 1,2,1);
imageplot(M2, <span class="string">'Frame #2'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_01.png"> <h2>Optical Flow Computation with Regularization<a name="12"></a></h2>
         <p>A first approach to optical flow computation is to solve a ill posed problem corresponding to the optical flow equation constraint
            (consistency of gray level intensity when moving along the flow).
         </p>
         <p>Compute the derivatives in time and space.</p><pre class="codeinput"><span class="keyword">global</span> D;
Dt = M1-M2;
D = grad(M1);
</pre><pre class="codeoutput">Warning: The value of local variables may have been changed to match the
globals.  Future versions of MATLAB will require that you declare a variable to
be global before you use that variable. 
</pre><p>Display them.</p><pre class="codeinput">clf;
imageplot(Dt, <span class="string">'d/dt'</span>, 1,3,1);
imageplot(D(:,:,1), <span class="string">'d/dx'</span>, 1,3,2);
imageplot(D(:,:,2), <span class="string">'d/dy'</span>, 1,3,3);
</pre><img vspace="5" hspace="5" src="index_02.png"> <p>The optical flow constraint asks for consistency of gray levels when moving along the flow <tt>v=[v1,v2]</tt>. This is written as a linear equation
         </p>
         <p><tt>Dt + v1.*D1 + v2.*D2=0</tt></p>
         <p>This equation does not constrain enough the flow (one equation for two unknown). One thus needs to add other constraints,
            and this is achieved by performing a Sobolev regularization, as first proposed by Horn and Schunck in the paper:
         </p>
         <p>Horn, B.K.P., and Schunck, B.G., <i>Determining Optical Flow</i>, AI(17), No. 1-3, August 1981, pp. 185-203
         </p>
         <p>This corresponds to a quadratic regularization with a Sobolev prior:</p>
         <p><tt>min_{v} norm(Dt + v1.*D1 + v2.*D2)^2 + lambda*norm(grad(v1))^2  + lambda*norm(grad(v2))^2</tt></p>
         <p>Its solution is computed by solving a linear system resolution, which sets to zero the gradient of the functional. It can
            be computed using a gradient descent, or, better, a conjugate gradient descent. We first detail the gradient descent, and
            shows that is not very efficient.
         </p>
         <p>Regularization strength.</p><pre class="codeinput"><span class="keyword">global</span> lambda;
lambda = .1;
</pre><pre class="codeoutput">Warning: The value of local variables may have been changed to match the
globals.  Future versions of MATLAB will require that you declare a variable to
be global before you use that variable. 
</pre><p>Gradient step size.</p><pre class="codeinput">tau = .2;
</pre><p>Initialization.</p><pre class="codeinput">v = zeros(n,n,2);
</pre><p>Compute the gradient of the functional. First compute <tt>Dt+v1*D1+v2*D2</tt></p><pre class="codeinput">U = Dt + sum(v.*D,3);
</pre><p>Then compute the Laplacian <tt>L(:,:,k)</tt> of each channel <tt>v(:,:,k)</tt> of the vector field
         </p><pre class="codeinput">L = cat(3, div(grad(v(:,:,1))), div(grad(v(:,:,2))));
</pre><p>And gather everything together to build the gradient of the functional.</p><pre class="codeinput">G = D.*repmat(U, [1 1 2])  - lambda * L;
</pre><p>Perform the descent.</p><pre class="codeinput">v = v - tau*G;
</pre><p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Perform the gradient descent of the energy, and display the decay of the energy.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_03.png"> <p>A much faster algorithm is the conjugate gradient. Several variant are implemented within matlab, and can be used by implementing
            a callback function.
         </p>
         <p>Set up parameters for the CG algorithm (tolerance and maximum number of iterations.</p><pre class="codeinput">tol = 1e-5;
maxit = 200;
</pre><p>Right hand side of the linear system.</p><pre class="codeinput">b = -D.*cat(3,Dt,Dt);
</pre><p>Resolution by conjugate gradient.</p><pre class="codeinput">[v,flag,relres,it,resvec] = cgs(@callback_optical_flow,b(:),tol,maxit);
v = reshape(v, [n n 2]);
</pre><p>Display the flow as a color image and as arrows.</p><pre class="codeinput">clf;
imageplot(v, <span class="string">''</span>, 1,2,1);
subplot(1,2,2);
w = 12; m = ceil(n/w);
t = w/2 + ((0:m-1)*w);
[V,U] = meshgrid(t,t);
hold <span class="string">on</span>;
imageplot(M1);
quiver(t,t,v(1:w:n,1:w:n,2), v(1:w:n,1:w:n,1));
axis(<span class="string">'ij'</span>);
</pre><img vspace="5" hspace="5" src="index_04.png"> <p>Compute the image warped along the flow.</p><pre class="codeinput"><span class="comment">% compute the grid, translated along the flow</span>
[Y,X] = meshgrid(1:n,1:n);
X = clamp(X+v(:,:,1),1,n);
Y = clamp(Y+v(:,:,2),1,n);
<span class="comment">% compute the first fame, translated along the flow</span>
Ms = interp2( 1:n,1:n, M1, Y,X );
</pre><p>One can compare the residual with and without the flow</p><pre class="codeinput"><span class="comment">% residual without flow</span>
R0 = M2-M1;
<span class="comment">% residual along the flow</span>
R = Ms-M1;
<span class="comment">% ensure same dynamic range (just for display)</span>
v = max( [max(abs(R0(:))) max(abs(R(:)))] );
R(1)=v; R(2)=-v; R0(1)=v; R0(2)=-v;
<span class="comment">% display</span>
clf;
imageplot(R0, <span class="string">'Residual without flow'</span>, 1,2,1);
imageplot(R, <span class="string">'Residual with flow'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_05.png"> <h2>Optical Flow Computation with Block Matching<a name="37"></a></h2>
         <p>A second approach to compute the optical flow is to perform local block matching, as first proposed by Lucas and Kanade in</p>
         <p>Lucas B D and Kanade T, <i>An iterative image registration technique with an application to stereo vision</i> Proceedings of Imaging understanding workshop, pp 121-130, 1981.
         </p>
         <p>The advantage is that this is more precise than the global Horn/Schunck method, and it might also be faster (no iterative
            scheme is needed). The desadvantage is that it does not regularize the flow in flat region.
         </p><pre class="codeinput"><span class="comment">% An optical flow is a vector field that describes</span>
<span class="comment">% the movement between to</span>
<span class="comment">% consecutive frames of the video.</span>
</pre><p>The flow can be computed by block matching. A block of <tt>(2*k+1,2*k+1)</tt> pixels in frame 1 around a location <tt>(x,y)</tt> is compared to the blocks at locations <tt>(x+dx,y+dy)</tt> for <tt>-q&lt;=dy,dx&lt;=q</tt> in the frame 2.
         </p><pre class="codeinput"><span class="comment">% width of the block</span>
w = 8;
<span class="comment">% search width</span>
q = 4;
<span class="comment">% sub-pixelic search if &lt;1</span>
dq = .5;
</pre><p>Number of flow vector is <tt>m^2</tt>.
         </p><pre class="codeinput">m = ceil(n/w);
</pre><p>Precompute movements vectors.</p><pre class="codeinput">[X0,Y0,dX,dY] = ndgrid( 0:w-1, 0:w-1, -q:dq:q,-q:dq:q);
[dy,dx] = meshgrid(-q:dq:q,-q:dq:q);
</pre><p>Start with empty optical flow. Each <tt>f=F(x,y,:)</tt> is a 2D vector mapping the patch at location <tt>(x,y)</tt> to the patch <tt>(x+f(1),y+f(2)</tt>.
         </p><pre class="codeinput">F = zeros(n,n,2);
</pre><p>Example of block number for wich the flow is computed. Each index should be less than <tt>m</tt></p><pre class="codeinput">i = 3; j = 40;
</pre><p>Pixel numbers.</p><pre class="codeinput">x = (i-1)*w+1;
y = (j-1)*w+1;
</pre><p>Block pixels index.</p><pre class="codeinput">selx = clamp( (i-1)*w+1:i*w, 1,n);
sely = clamp( (j-1)*w+1:j*w, 1,n);
</pre><p>A special care should be taken at the boundary : we simply clamp values outside boundaries</p><pre class="codeinput">X = clamp(x + X0 + dX,1,n);
Y = clamp(y + Y0 + dY,1,n);
</pre><p>Compute base patch of <tt>M2</tt> at which the flow is computed.
         </p><pre class="codeinput">P2 = M2(selx,sely);
</pre><p>Compute patches of <tt>M1</tt> that are matched. Use interpolation to handle non indeger pixel indexes.
         </p><pre class="codeinput">P1 = interp2( 1:n,1:n, M1, Y,X );
</pre><p>Compute the distance between <tt>P1</tt> and all the patches of <tt>P2</tt>.
         </p><pre class="codeinput">d = sum(sum( (P1-repmat(P2,[1 1 size(P1,3) size(P1,4)])).^2 ) );
</pre><p>Compute best match and report its value.</p><pre class="codeinput">[tmp,I] = compute_min(d(:));
F(selx,sely,1) = dx(I);
F(selx,sely,2) = dy(I);
</pre><p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Compute the whole optical flow <tt>F</tt>, by cycling through the pixels.
         </p><pre class="codeinput">exo2;
</pre><p>Display the flow as a color image and as arrows.</p><pre class="codeinput">clf;
imageplot(F, <span class="string">''</span>, 1,2,1);
subplot(1,2,2);
t = w/2 + ((0:m-1)*w);
[V,U] = meshgrid(t,t);
hold <span class="string">on</span>;
imageplot(M1);
quiver(t,t,F(1:w:n,1:w:n,2), F(1:w:n,1:w:n,1));
axis(<span class="string">'ij'</span>);
</pre><img vspace="5" hspace="5" src="index_06.png"> <h2>Residual Computation<a name="54"></a></h2>
         <p>The optical flow <tt>F</tt> allows one to compute the residual <tt>R</tt> between frame <tt>M2</tt> and an extrapolated version of <tt>M1</tt> along the flow <tt>F</tt>.
         </p>
         <p>One can translate the first frame <tt>M1</tt> along the flow <tt>F</tt>.
         </p><pre class="codeinput"><span class="comment">% compute the grid, translated along the flow</span>
[Y,X] = meshgrid(1:n,1:n);
X = clamp(X+F(:,:,1),1,n);
Y = clamp(Y+F(:,:,2),1,n);
<span class="comment">% compute the first fame, translated along the flow</span>
Ms = interp2( 1:n,1:n, M1, Y,X );
</pre><p>One can compare the residual with and without the flow</p><pre class="codeinput"><span class="comment">% residual without flow</span>
R0 = M2-M1;
<span class="comment">% residual along the flow</span>
R = M2-Ms;
<span class="comment">% ensure same dynamic range (just for display)</span>
v = max( [max(abs(R0(:))) max(abs(R(:)))] );
R(1)=v; R(2)=-v; R0(1)=v; R0(2)=-v;
<span class="comment">% display</span>
clf;
imageplot(R0, <span class="string">'Residual without flow'</span>, 1,2,1);
imageplot(R, <span class="string">'Residual with flow'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_07.png"> <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Optical Flow Computation
% This numerical tour explores the computation of optical flow between two
% images. It is at the heart of video coding.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox> and 
% <../toolbox_general.zip general toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal| and 
% |toolbox_general|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');

%% Loading Warped Images
% To evaluate the performance of optical flow computation, we compute a
% pair of image obtained by a smooth warping (small deformation),
% here a simple rotation.

%%
% Original frame #1.

n = 256;
name = 'lena';
M1 = rescale( load_image(name,n) );

%%
% The second image |M2| is obtaind by rotating the first one.

% angle of rotation
theta = .03 * pi/2;
% original coordinates
[Y,X] = meshgrid(1:n,1:n);
% rotated coordinates
X1 = (X-n/2)*cos(theta) + (Y-n/2)*sin(theta) + n/2;
Y1 =-(X-n/2)*sin(theta) + (Y-n/2)*cos(theta) + n/2;
% boundary handling
X1 = mod(X1-1,n)+1;
Y1 = mod(Y1-1,n)+1;
% interpolation
M2 = interp2(Y,X,M1,Y1,X1);
M2(isnan(M2)) = 0;

%%
% Display the two images.

clf;
imageplot(M1, 'Frame #1', 1,2,1);
imageplot(M2, 'Frame #2', 1,2,2);


%% Optical Flow Computation with Regularization
% A first approach to optical flow computation is to solve a ill posed
% problem corresponding to the optical flow equation constraint
% (consistency of gray level intensity when moving along the flow).

%% 
% Compute the derivatives in time and space. 

global D;
Dt = M1-M2;
D = grad(M1);

%%
% Display them.

clf;
imageplot(Dt, 'd/dt', 1,3,1);
imageplot(D(:,:,1), 'd/dx', 1,3,2);
imageplot(D(:,:,2), 'd/dy', 1,3,3);

%%
% The optical flow constraint asks for consistency of gray levels when moving
% along the flow |v=[v1,v2]|. This is written as a linear equation

%%
% |Dt + v1.*D1 + v2.*D2=0|

%%
% This equation does not constrain enough the flow (one equation for two
% unknown). One thus needs to add other constraints, and this is achieved
% by performing a Sobolev regularization, as first proposed by Horn and
% Schunck in the paper:

%%
% Horn, B.K.P., and Schunck, B.G., 
% _Determining Optical Flow_, AI(17), No. 1-3, August 1981, pp. 185-203 


%%
% This corresponds to a quadratic regularization with a Sobolev prior:


%%
% |min_{v} norm(Dt + v1.*D1 + v2.*D2)^2 + lambda*norm(grad(v1))^2  + lambda*norm(grad(v2))^2|

%%
% Its solution is computed by solving a linear system resolution, which sets to zero the gradient of the functional.
% It can be computed using a gradient descent, or, better, a conjugate gradient descent.
% We first detail the gradient descent, and shows that is not very
% efficient.

%%
% Regularization strength.

global lambda;
lambda = .1;


%%
% Gradient step size.

tau = .2;

%%
% Initialization.

v = zeros(n,n,2);

%% 
% Compute the gradient of the functional.
% First compute |Dt+v1*D1+v2*D2|

U = Dt + sum(v.*D,3);

%%
% Then compute the Laplacian |L(:,:,k)| of each channel |v(:,:,k)| of the vector field

L = cat(3, div(grad(v(:,:,1))), div(grad(v(:,:,2))));

%%
% And gather everything together to build the gradient of the functional.

G = D.*repmat(U, [1 1 2])  - lambda * L;
    
%%
% Perform the descent.

v = v - tau*G;

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Perform the gradient descent of the energy, and display the decay of the
% energy.

exo1;

%%
% A much faster algorithm is the conjugate gradient. Several variant are
% implemented within matlab, and can be used by implementing a callback
% function.

%% 
% Set up parameters for the CG algorithm (tolerance and maximum number of
% iterations.

tol = 1e-5;
maxit = 200;

%%
% Right hand side of the linear system.

b = -D.*cat(3,Dt,Dt);

%% 
% Resolution by conjugate gradient.

[v,flag,relres,it,resvec] = cgs(@callback_optical_flow,b(:),tol,maxit);
v = reshape(v, [n n 2]);

%%
% Display the flow as a color image and as arrows.

clf;
imageplot(v, '', 1,2,1);
subplot(1,2,2);
w = 12; m = ceil(n/w);
t = w/2 + ((0:m-1)*w);
[V,U] = meshgrid(t,t);
hold on;
imageplot(M1);
quiver(t,t,v(1:w:n,1:w:n,2), v(1:w:n,1:w:n,1));
axis('ij');

%% 
% Compute the image warped along the flow.

% compute the grid, translated along the flow
[Y,X] = meshgrid(1:n,1:n);
X = clamp(X+v(:,:,1),1,n);
Y = clamp(Y+v(:,:,2),1,n);
% compute the first fame, translated along the flow
Ms = interp2( 1:n,1:n, M1, Y,X );

%%
% One can compare the residual with and without the flow

% residual without flow
R0 = M2-M1;
% residual along the flow
R = Ms-M1;
% ensure same dynamic range (just for display)
v = max( [max(abs(R0(:))) max(abs(R(:)))] );
R(1)=v; R(2)=-v; R0(1)=v; R0(2)=-v;
% display
clf;
imageplot(R0, 'Residual without flow', 1,2,1);
imageplot(R, 'Residual with flow', 1,2,2);


%% Optical Flow Computation with Block Matching
% A second approach to compute the optical flow is to perform local block
% matching, as first proposed by Lucas and Kanade in 

%%
% Lucas B D and Kanade T, 
% _An iterative image registration technique with an application to stereo vision_ 
% Proceedings of Imaging understanding workshop, pp 121-130, 1981.

%%
% The advantage is that this is more precise than the global Horn/Schunck
% method, and it might also be faster (no iterative scheme is needed). The
% desadvantage is that it does not regularize the flow in flat region.

% An optical flow is a vector field that describes
% the movement between to
% consecutive frames of the video. 

%%
% The flow can be computed by block matching. A block of |(2*k+1,2*k+1)|
% pixels in frame 1 around a location |(x,y)| is compared to the blocks at locations
% |(x+dx,y+dy)| for |-q<=dy,dx<=q| in the frame 2.

% width of the block
w = 8;
% search width
q = 4;
% sub-pixelic search if <1
dq = .5;

%%
% Number of flow vector is |m^2|.

m = ceil(n/w);

%%
% Precompute movements vectors.

[X0,Y0,dX,dY] = ndgrid( 0:w-1, 0:w-1, -q:dq:q,-q:dq:q);
[dy,dx] = meshgrid(-q:dq:q,-q:dq:q);

%%
% Start with empty optical flow. Each |f=F(x,y,:)| is a 2D vector mapping the
% patch at location |(x,y)| to the patch |(x+f(1),y+f(2)|.

F = zeros(n,n,2);

%%
% Example of block number for wich the flow is computed. Each index should
% be less than |m|

i = 3; j = 40;

%%
% Pixel numbers.

x = (i-1)*w+1;
y = (j-1)*w+1;

%%
% Block pixels index.

selx = clamp( (i-1)*w+1:i*w, 1,n);
sely = clamp( (j-1)*w+1:j*w, 1,n);

%%
% A special care should be taken at the boundary : we simply clamp values
% outside boundaries

X = clamp(x + X0 + dX,1,n);
Y = clamp(y + Y0 + dY,1,n);

%%
% Compute base patch of |M2| at which the flow is computed.

P2 = M2(selx,sely);

%%
% Compute patches of |M1| that are matched. Use interpolation to handle non
% indeger pixel indexes.

P1 = interp2( 1:n,1:n, M1, Y,X );

%%
% Compute the distance between |P1| and all the patches of |P2|.

d = sum(sum( (P1-repmat(P2,[1 1 size(P1,3) size(P1,4)])).^2 ) );

%%
% Compute best match and report its value.

[tmp,I] = compute_min(d(:));
F(selx,sely,1) = dx(I);
F(selx,sely,2) = dy(I);


%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Compute the whole optical flow |F|, by cycling through the pixels.

exo2;

%% 
% Display the flow as a color image and as arrows.

clf;
imageplot(F, '', 1,2,1);
subplot(1,2,2);
t = w/2 + ((0:m-1)*w);
[V,U] = meshgrid(t,t);
hold on;
imageplot(M1);
quiver(t,t,F(1:w:n,1:w:n,2), F(1:w:n,1:w:n,1));
axis('ij');



%% Residual Computation
% The optical flow |F| allows one to compute the residual |R| between frame |M2| 
% and an extrapolated version of |M1| along the flow |F|.

%%
% One can translate the first frame |M1| along the flow |F|.

% compute the grid, translated along the flow
[Y,X] = meshgrid(1:n,1:n);
X = clamp(X+F(:,:,1),1,n);
Y = clamp(Y+F(:,:,2),1,n);
% compute the first fame, translated along the flow
Ms = interp2( 1:n,1:n, M1, Y,X );

%%
% One can compare the residual with and without the flow

% residual without flow
R0 = M2-M1;
% residual along the flow
R = M2-Ms;
% ensure same dynamic range (just for display)
v = max( [max(abs(R0(:))) max(abs(R(:)))] );
R(1)=v; R(2)=-v; R0(1)=v; R0(2)=-v;
% display
clf;
imageplot(R0, 'Residual without flow', 1,2,1);
imageplot(R, 'Residual with flow', 1,2,2);
##### SOURCE END #####
-->
   </body>
</html>