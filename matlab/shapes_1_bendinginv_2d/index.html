
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Geodesic Bending Invariants for Shapes</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-21">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Geodesic Bending Invariants for Shapes</h1>
         <introduction>
            <p>This tour explores the computation of bending invariants of shapes.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Bending Invariants</a></li>
               <li><a href="#14">2-D Shapes</a></li>
               <li><a href="#18">Geodesic Distance</a></li>
               <li><a href="#25">Geodesic Distance Matrix</a></li>
               <li><a href="#35">Bending Invariant with Strain Minimization</a></li>
               <li><a href="#42">Bending Invariant with Stress Minimization</a></li>
               <li><a href="#52">Shape Retrieval with Bending Invariant.</a></li>
               <li><a href="#55">Bibliography</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a>, <a href="../toolbox_general.zip">general toolbox</a> and <a href="../toolbox_graph.zip">graph toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt>, <tt>toolbox_general</tt> and <tt>toolbox_graph</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
getd(<span class="string">'toolbox_graph/'</span>);
</pre><h2>Bending Invariants<a name="8"></a></h2>
         <p>Bending invariants replace the position of the vertices in a shape \(\Ss\) (2-D or 3-D) by new positions that are insensitive
            to isometric deformation of the shape. This defines a bending invariant signature that can be used for surface matching.
         </p>
         <p>Bending invariant were introduced in <a href="#biblio">[EladKim03]</a>. A related method was developped for brain flattening in <a href="#biblio">[SchwShWolf89]</a>. This method is related to the Isomap algorithm for manifold learning <a href="#biblio">[TenSolvLang03]</a>.
         </p>
         <p>We assume that \(Ss\) has some Riemannian metric, for instance coming from the embedding of a surface in 3-D Euclidian space,
            or by restriction of the Euclian 2-D space to a 2-D sub-domain (planar shape). One thus can compute the geodesic distance
            \(d(x,x')\) between points \(x,x' \in \Ss\).
         </p>
         <p>The bending invariant \(\tilde \Ss\) of \(\Ss\) is defined as the set of points \(Y = (y_i)_j \subset \RR^d\) that are optimized
            so that the Euclidean distance between points in \(Y\) matches as closely the geodesic distance between points in \(X\), i.e.
            \[ \forall i, j, \quad \norm{y_i-y_j} \approx d(x_i,x_j) \]
         </p>
         <p>Multi-dimensional scaling (MDS) is a class of method that aims at computing such a set of points \(Y \in \RR^{d \times N}\)
            in \(\RR^d\) such that \[ \forall i, j, \quad \norm{y_i-y_j} \approx \de_{i,j} \] where \(\de \in \RR^{N \times N}\) is a
            input data matrix. For a detailed overview of MDS, we refer to the book <a href="#biblio">[BorgGroe97]</a></p>
         <p>In this tour, we apply two specific MDS algorithms (strain and stress minimization) with input \(\de_{i,j} = d(x_i,x_j)\).</p>
         <h2>2-D Shapes<a name="14"></a></h2>
         <p>We consider here the case where \(\Ss\) is a sub-domain of \(\RR^2\).</p>
         <p>A binary shape \(\Ss\) is represented as a binary image \(S \in \RR^Q\) of \(Q=q \times q\) pixels.</p><pre class="codeinput">clear <span class="string">options</span>;
q = 400;
name = <span class="string">'centaur1'</span>;
S = load_image(name,q);
S = perform_blurring(S,5);
S = double( rescale( S )&gt;.5 );
<span class="keyword">if</span> S(1)==1
    S = 1-S;
<span class="keyword">end</span>
</pre><p>Compute its boundary \(b = (b_i)_{i=1}^L \in \RR^{2 \times L}\).</p><pre class="codeinput">b = compute_shape_boundary(S);
L = size(b,2);
</pre><p>Display the shape.</p><pre class="codeinput">lw = 2;
clf; hold <span class="string">on</span>;
imageplot(-S);
plot(b(2,:), b(1,:), <span class="string">'r'</span>, <span class="string">'LineWidth'</span>, lw); axis <span class="string">ij</span>;
</pre><img vspace="5" hspace="5" src="index_01.png"> <h2>Geodesic Distance<a name="18"></a></h2>
         <p>We consider the geodesic distance obtained by contraining the shortest curve to be inside \(\Ss\) \[ d(x,x') = \umin{ \ga
            } \int_0^1 \abs{\ga'(t)} d t, \] where \(\ga\) should satisfy \[ \ga(0)=x, \quad \ga(1)=x' \qandq \forall t \in [0,1], \:
            \ga(t) \in \Ss. \]
         </p>
         <p>The geodesic distance map \(U(x) = d(x,x_0)\) to a starting point \(x_0\) can be computed in \(O(q^2 \log(q))\) operations
            on a grid of \(q \times q\) points using the Fast Marching algorithm.
         </p>
         <p>Design a constraint map for the Fast-Marching, to enforce the propagation inside the shape.</p><pre class="codeinput">S1 = perform_convolution(S, ones(3)/9)&lt;.01; S1=double(S1==0);
C = zeros(q)-Inf; C(S1==1) = +Inf;
options.constraint_map = C;
</pre><p>Shortcut to compute the geodesic distance to some point \(x\).</p><pre class="codeinput">geod = @(x)perform_fast_marching(ones(q), x, options);
</pre><p>Compute the geodesic distance to a point \(x\)</p><pre class="codeinput">x = [263; 55];
options.nb_iter_max = Inf;
U = geod(x);
</pre><p>Display the distance and geodesic curves.</p><pre class="codeinput">clf;
options.display_levelsets = 1;
options.pstart = x;
options.nbr_levelsets = 60;
U(S==0) = Inf;
display_shape_function(U, options);
</pre><img vspace="5" hspace="5" src="index_02.png"> <p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Compute curves joining the start point to several points along the boundary.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_03.png"> <h2>Geodesic Distance Matrix<a name="25"></a></h2>
         <p>We define a set \(X = (x_i)_{i=1}^n \in \RR^{2 \times N} \subset \Ss\) of sampling points.</p>
         <p>Total number \(N\) of sampling points.</p><pre class="codeinput">N = 1000;
</pre><p>The sampling is made of \(N_0\) points on the boundary \(b\), and \(N-N_0\) points inside the shape \(\Ss\).</p>
         <p>Number of points on the boundary.</p><pre class="codeinput">N0 = round(.4*N);
</pre><p>Sampling on the boundary.</p><pre class="codeinput">I = round(linspace(1,L+1,N0+1));
X = round(b(:,I(1:end-1)));
</pre><p>Add \(N-N_0\) points inside the shape.</p><pre class="codeinput">[y,x] = meshgrid(1:q,1:q);
I = find(S==1);
I = I(randperm(length(I))); I = I(1:N-N0);
X(:,end+1:N) = [x(I),y(I)]';
</pre><p>Display the sampling points.</p><pre class="codeinput">clf; hold <span class="string">on</span>;
imageplot(1-S);
plot(X(2,:), X(1,:), <span class="string">'r.'</span>, <span class="string">'MarkerSize'</span>, 15);
axis(<span class="string">'ij'</span>);
</pre><img vspace="5" hspace="5" src="index_04.png"> <p>The geodesic distance matrix \(\de \in \RR^{N \times N}\) is defined as \[ \forall i,j=1,\ldots,N, \quad       \de_{i,j} =
            d(x_i,x_j). \]
         </p>
         <p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Compute the geodesic distance matrix \(\de\).
         </p><pre class="codeinput">exo2;
</pre><p>Display the geodesic matrix for \(1 \leq i,j \leq N_0\) (points along the boundary \(b\)).</p><pre class="codeinput">clf;
imageplot(delta(1:N0,1:N0));
colormap(jet(256));
</pre><img vspace="5" hspace="5" src="index_05.png"> <h2>Bending Invariant with Strain Minimization<a name="35"></a></h2>
         <p>The goal is to compute a set of points \(Y = (y_i)_{i=1}^N\) in \(\RR^d\), (here we use \(d=2\)) stored in a matrix \(Y \in
            \RR^{d \times N}\) such that \[ \forall i, j, \quad D^2(Y)_{i,j} \approx \de_{i,j}^2   \qwhereq  D^2(Y)_{i,j} = \norm{y_i-y_j}^2.
            \]
         </p>
         <p>This can be achieved by minimzing a \(L^2\) loss \[ \umin{Y} \norm{ D^2(Y)-\de^2 }^2 =       \sum_{i&lt;j} \abs{ \norm{y_i-y_j}^2
            - \de_{i,j}^2 }^2. \]
         </p>
         <p>Strain minimization consider instead the following weighted \(L^2\) loss (so-called strain) \[ \umin{Y \in \RR^{d \times N}
            } \text{Strain}(Y)       = \norm{ J ( D^2(Y)-\de^2 ) J }^2 \] where \(J\) is the so-called centering matrix \[ J_{i,j} = 
                 \choice{           1-1/N \qifq i=j, \\           -1/N \qifq i \neq j.  }\]
         </p><pre class="codeinput">J = eye(N) - ones(N)/N;
</pre><p>Using the properties of squared-distance matrices \(D^2(Y)\), one can show that \[ \norm{ J ( D^2(Y)-\de^2 ) J }^2 =   \norm{
            Y Y^* - K }^2   \qwhereq K = - \frac{1}{2} J \de^2 J. \]
         </p><pre class="codeinput">K = -1/2 * J*(delta.^2)*J;
</pre><p>The solution to this (non-convex) optimization problem can be computed exactly as the rows of \(Y\) being the two leading
            eigenvectors of \(K\) propery rescaled.
         </p><pre class="codeinput">opt.disp = 0;
[Y, v] = eigs(K, 2, <span class="string">'LR'</span>, opt);
Y = Y .* repmat(sqrt(diag(v))', [N 1]);
Y = Y';
</pre><p>Extract the boundary part of the mapped data. Rotate the shape if necessary.</p><pre class="codeinput">theta = -.8*pi;
uv = Y(:,1:N0);
uv = [cos(theta)*uv(1,:) + sin(theta)*uv(2,:); - sin(theta)*uv(1,:) + cos(theta)*uv(2,:)];
</pre><p>Display the bending invariant boundary.</p><pre class="codeinput">clf;
h = plot(uv(2,:), uv(1,:));
axis(<span class="string">'ij'</span>); axis(<span class="string">'equal'</span>); axis(<span class="string">'off'</span>);
set(h, <span class="string">'LineWidth'</span>, lw);
</pre><img vspace="5" hspace="5" src="index_06.png"> <h2>Bending Invariant with Stress Minimization<a name="42"></a></h2>
         <p>The stress functional does not have geometrical meaning. An alternative MDS method directly minimizes a geometric loss, the
            so-called Stress \[ \umin{Y \in \RR^{d \times N} } \text{Stress}(Y) =       \norm{ D(Y)-\de }^2 =       \sum_{i&lt;j} \abs{ \norm{y_i-y_j}
            - \de_{i,j} }^2.  \] It is possible to find a local minimizer of this energy by various descent algorithms, as initially proposed
            by <a href="#biblio">[Kruskal64]</a></p><pre class="codeinput">Stress = @(d)sqrt( sum( abs(delta(:)-d(:)).^2 ) / N^2 );
</pre><p>Operator to compute the distance matrix \(D(Y)\).</p><pre class="codeinput">D = @(Y)sqrt( repmat(sum(Y.^2),N,1) + repmat(sum(Y.^2),N,1)' - 2*Y'*Y);
</pre><p>The SMACOF (Scaling by majorizing a convex function) algorithm solves at each iterations a quadratic energy, that is guaranteed
            to diminish the value of the Strain. It was introduced by <a href="#biblio">[Leeuw77]</a></p>
         <p>It computes iterates \(X^{(\ell)}\) as \[ X^{(\ell+1)} = \frac{1}{N} X^{(\ell)} B(D(X^{(\ell)}))^*,  \] where \[ B(D) = \choice{
                     -\frac{\de_{i,j}}{D_{i,j}} \qifq i \neq j, \\          -\sum_{k} B(D)_{i,k} \qifq i = j. } \]
         </p>
         <p>Initialize the positions for the algorithm.</p><pre class="codeinput">Y = X/q;
</pre><p>Operator \(B\).</p><pre class="codeinput">remove_diag = @(b)b - diag(sum(b));
B = @(D1)remove_diag( -delta./max(D1,1e-10) );
</pre><p>Update the positions.</p><pre class="codeinput">Y = Y * B(D(Y))' / N;
</pre><p><i>Exercice 3:</i> (<a href="../missing-exo/">check the solution</a>) Perform the SMACOF iterative algorithm. Save in a variable <tt>s(l)</tt> the values of Stress\(( X^{(\ell)} )\).
         </p><pre class="codeinput">exo3;
</pre><img vspace="5" hspace="5" src="index_07.png"> <p>Plot stress evolution during minimization.</p><pre class="codeinput">clf;
plot(s, <span class="string">'.-'</span>, <span class="string">'LineWidth'</span>, 2, <span class="string">'MarkerSize'</span>, 20);
axis(<span class="string">'tight'</span>);
</pre><img vspace="5" hspace="5" src="index_08.png"> <p>Plot the optimized invariant shape.</p><pre class="codeinput">clf;
h = plot(Y(2,[1:N0 1]), Y(1,[1:N0 1]));
axis(<span class="string">'ij'</span>); axis(<span class="string">'equal'</span>); axis(<span class="string">'off'</span>);
set(h, <span class="string">'LineWidth'</span>, lw);
</pre><img vspace="5" hspace="5" src="index_09.png"> <h2>Shape Retrieval with Bending Invariant.<a name="52"></a></h2>
         <p>One can compute a bending invariant signature for each shape in a library of images.</p>
         <p>Isometry-invariant retrival is then perform by matching the invariant signature.</p>
         <p><i>Exercice 4:</i> (<a href="../missing-exo/">check the solution</a>) Implement a shape retrival algorithm based on these bending invariants.
         </p><pre class="codeinput">exo4;
</pre><h2>Bibliography<a name="55"></a></h2>
         <p><a name="biblio"></a></p>
         <div>
            <ul>
               <li>[EladKim03]&nbsp;A. Elad and R. Kimmel, <a href="http://dx.doi.org/10.1109/TPAMI.2003.1233902"><i>On bending invariant signatures for surfaces</i></a>, IEEE Transactions onPattern Analysis and Machine Intelligence, Vol. 25(10), p. 1285-1295, 2003.
               </li>
               <li>[SchwShWolf89] E.L. Schwartz and A. Shaw and E. Wolfson, <a href="http://dx.doi.org/10.1109/34.35506"><i>A Numerical Solution to the Generalized Mapmaker's Problem: Flattening Nonconvex Polyhedral Surfaces</i></a>, IEEE Transactions on Pattern Analysis and Machine Intelligence, 11(9), p. 1005-1008, 1989.
               </li>
               <li>[TenSolvLang03] J. B. Tenenbaum, V. de Silva and J. C. Langford, <a href="http://dx.doi.org/10.1126/science.290.5500.2319"><i>A Global Geometric Framework for Nonlinear Dimensionality Reduction</i></a>, Science 290 (5500): 2319-2323, 22 December 2000
               </li>
               <li>[Kruskal64] J. B. Kruskal, <a href="http://dx.doi.org/10.1007/BF02289565"><i>Multidimensional scaling by optimizing goodness of fit to a nonmetric hypothesis</i></a>, Psychometrika 29 (1): 1?27, 1964.
               </li>
               <li>[Leeuw77] J. de Leeuw, <a href="http://statistics.ucla.edu/preprints/uclastat-preprint-2005:35"><i>Applications of convex analysis to multidimensional scaling</i></a>, in Recent developments in statistics, pp. 133?145, 1977
               </li>
               <li>[BorgGroe97] I. Borg and P. Groenen, <a href="http://www.springeronline.com/0-387-25150-2"><i>Modern Multidimensional Scaling: theory and applications</i></a>, New York: Springer-Verlag, 1997.
               </li>
            </ul>
         </div>
         <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Geodesic Bending Invariants for Shapes
% This tour explores the computation of bending invariants of shapes.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox>, 
% <../toolbox_general.zip general toolbox> and 
% <../toolbox_graph.zip graph toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal|, 
% |toolbox_general| and 
% |toolbox_graph|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');
getd('toolbox_graph/');


%% Bending Invariants
% Bending invariants replace the position of the vertices in a shape \(\Ss\) (2-D or 3-D)
% by new positions that are insensitive to isometric deformation of the shape.
% This defines a bending invariant signature that can be used for surface
% matching.
  
%% 
% Bending invariant were introduced in <#biblio [EladKim03]>.
% A related method was developped for brain flattening in <#biblio [SchwShWolf89]>.
% This method is related to the Isomap algorithm for manifold learning
% <#biblio [TenSolvLang03]>.

%% 
% We assume that \(Ss\) has some Riemannian metric, for instance coming
% from the embedding of a surface in 3-D Euclidian space, or by restriction of 
% the Euclian 2-D space to a 2-D sub-domain (planar shape). One thus can
% compute the geodesic distance \(d(x,x')\) between points \(x,x' \in
% \Ss\).

%%
% The bending invariant \(\tilde \Ss\) of \(\Ss\) is defined as the set of
% points \(Y = (y_i)_j \subset \RR^d\) that are optimized so that the Euclidean
% distance between points in \(Y\) matches as closely the geodesic distance
% between points in \(X\), i.e.
% \[ \forall i, j, \quad \norm{y_i-y_j} \approx d(x_i,x_j) \]

%%
% Multi-dimensional scaling (MDS) is a class of method that aims at
% computing such a set of points \(Y \in \RR^{d \times N}\) in \(\RR^d\)
% such that 
% \[ \forall i, j, \quad \norm{y_i-y_j} \approx \de_{i,j} \]
% where \(\de \in \RR^{N \times N}\) is a input data matrix. 
% For a detailed overview of MDS, we refer to the book <#biblio [BorgGroe97]>

%%
% In this tour, we apply two specific MDS algorithms (strain and stress
% minimization) with input \(\de_{i,j} = d(x_i,x_j)\).

%% 2-D Shapes
% We consider here the case where \(\Ss\) is a sub-domain of \(\RR^2\).

%%
% A binary shape \(\Ss\) is represented as a binary image \(S \in \RR^Q\)
% of \(Q=q \times q\) pixels.

clear options;
q = 400;
name = 'centaur1';
S = load_image(name,q);
S = perform_blurring(S,5);
S = double( rescale( S )>.5 );
if S(1)==1 
    S = 1-S;
end

%%
% Compute its boundary \(b = (b_i)_{i=1}^L \in \RR^{2 \times L}\).

b = compute_shape_boundary(S);
L = size(b,2);

%%
% Display the shape.

lw = 2;
clf; hold on;
imageplot(-S);
plot(b(2,:), b(1,:), 'r', 'LineWidth', lw); axis ij;


%% Geodesic Distance
% We consider the geodesic distance obtained by contraining the shortest
% curve to be inside \(\Ss\)
% \[ d(x,x') = \umin{ \ga } \int_0^1 \abs{\ga'(t)} d t, \]
% where \(\ga\) should satisfy
% \[ \ga(0)=x, \quad \ga(1)=x' \qandq \forall t \in [0,1], \: \ga(t) \in \Ss. \]

%%
% The geodesic distance map \(U(x) = d(x,x_0)\) to a starting point \(x_0\)
% can be computed in \(O(q^2 \log(q))\) operations on a grid of \(q \times
% q\) points using the Fast Marching algorithm.


%%
% Design a constraint map for the Fast-Marching, to enforce the propagation
% inside the shape.

S1 = perform_convolution(S, ones(3)/9)<.01; S1=double(S1==0);
C = zeros(q)-Inf; C(S1==1) = +Inf;
options.constraint_map = C;

%% 
% Shortcut to compute the geodesic distance to some point \(x\).

geod = @(x)perform_fast_marching(ones(q), x, options);

%%
% Compute the geodesic distance to a point \(x\)

x = [263; 55];
options.nb_iter_max = Inf;
U = geod(x);

%%
% Display the distance and geodesic curves. 

clf;
options.display_levelsets = 1;
options.pstart = x;
options.nbr_levelsets = 60;
U(S==0) = Inf;
display_shape_function(U, options);

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Compute curves joining the start point to several points along the
% boundary.

exo1;

%% Geodesic Distance Matrix
% We define a set \(X = (x_i)_{i=1}^n \in \RR^{2 \times N} \subset \Ss\)
% of sampling points.

%%
% Total number \(N\) of sampling points.

N = 1000;

%%
% The sampling is made of \(N_0\) points on the boundary \(b\), 
% and \(N-N_0\) points inside the shape \(\Ss\).

%%
% Number of points on the boundary. 

N0 = round(.4*N);

%%
% Sampling on the boundary. 

I = round(linspace(1,L+1,N0+1));
X = round(b(:,I(1:end-1)));

%% 
% Add \(N-N_0\) points inside the shape.

[y,x] = meshgrid(1:q,1:q);
I = find(S==1);
I = I(randperm(length(I))); I = I(1:N-N0);
X(:,end+1:N) = [x(I),y(I)]';

%%
% Display the sampling points.

clf; hold on;
imageplot(1-S);
plot(X(2,:), X(1,:), 'r.', 'MarkerSize', 15);
axis('ij');

%%
% The geodesic distance matrix \(\de \in \RR^{N \times N}\) is defined as
% \[ \forall i,j=1,\ldots,N, \quad
%       \de_{i,j} = d(x_i,x_j). \]

%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Compute the geodesic distance matrix \(\de\).

exo2;


%%
% Display the geodesic matrix for \(1 \leq i,j \leq N_0\)
% (points along the boundary \(b\)).

clf;
imageplot(delta(1:N0,1:N0));
colormap(jet(256));

%% Bending Invariant with Strain Minimization
% The goal is to compute a set of points \(Y = (y_i)_{i=1}^N\) in
% \(\RR^d\), (here we use \(d=2\)) stored in a matrix \(Y \in \RR^{d \times N}\)
% such that
% \[ \forall i, j, \quad D^2(Y)_{i,j} \approx \de_{i,j}^2 
%   \qwhereq  D^2(Y)_{i,j} = \norm{y_i-y_j}^2. \]

%%
% This can be achieved by minimzing a \(L^2\) loss
% \[ \umin{Y} \norm{ D^2(Y)-\de^2 }^2 = 
%       \sum_{i<j} \abs{ \norm{y_i-y_j}^2 - \de_{i,j}^2 }^2. \]

%%
% Strain minimization consider instead the following weighted \(L^2\) loss
% (so-called strain)
% \[ \umin{Y \in \RR^{d \times N} } \text{Strain}(Y) 
%       = \norm{ J ( D^2(Y)-\de^2 ) J }^2
% \]
% where \(J\) is the so-called centering matrix
% \[ J_{i,j} =  
%       \choice{
%           1-1/N \qifq i=j, \\
%           -1/N \qifq i \neq j.
%  }\]

J = eye(N) - ones(N)/N;

%%
% Using the properties of squared-distance matrices \(D^2(Y)\), one can
% show that 
% \[ \norm{ J ( D^2(Y)-\de^2 ) J }^2 = 
%   \norm{ Y Y^* - K }^2 
%   \qwhereq K = - \frac{1}{2} J \de^2 J. \]

K = -1/2 * J*(delta.^2)*J;

%%
% The solution to this (non-convex) optimization problem can be computed
% exactly as the rows of \(Y\) being the two leading eigenvectors of \(K\)
% propery rescaled.

opt.disp = 0; 
[Y, v] = eigs(K, 2, 'LR', opt);
Y = Y .* repmat(sqrt(diag(v))', [N 1]);
Y = Y';

%%
% Extract the boundary part of the mapped data.
% Rotate the shape if necessary.

theta = -.8*pi;
uv = Y(:,1:N0);
uv = [cos(theta)*uv(1,:) + sin(theta)*uv(2,:); - sin(theta)*uv(1,:) + cos(theta)*uv(2,:)];

%%
% Display the bending invariant boundary.

clf;
h = plot(uv(2,:), uv(1,:)); 
axis('ij'); axis('equal'); axis('off');
set(h, 'LineWidth', lw);



%% Bending Invariant with Stress Minimization
% The stress functional does not have geometrical meaning. 
% An alternative MDS method directly minimizes a geometric loss, the
% so-called Stress
% \[ \umin{Y \in \RR^{d \times N} } \text{Stress}(Y) = 
%       \norm{ D(Y)-\de }^2 = 
%       \sum_{i<j} \abs{ \norm{y_i-y_j} - \de_{i,j} }^2. 
%  \]
% It is possible to find a local minimizer of this energy by various
% descent algorithms, as initially proposed by <#biblio [Kruskal64]>

Stress = @(d)sqrt( sum( abs(delta(:)-d(:)).^2 ) / N^2 ); 

%%
% Operator to compute the distance matrix \(D(Y)\).

D = @(Y)sqrt( repmat(sum(Y.^2),N,1) + repmat(sum(Y.^2),N,1)' - 2*Y'*Y);

%%
% The SMACOF (Scaling by majorizing a convex function) algorithm 
% solves at each iterations a quadratic energy, that is guaranteed to 
% diminish the value of the Strain. It was introduced by <#biblio [Leeuw77]>

%%
% It computes iterates \(X^{(\ell)}\) as
% \[ X^{(\ell+1)} = \frac{1}{N} X^{(\ell)} B(D(X^{(\ell)}))^*,  \]
% where 
% \[ B(D) = \choice{
%          -\frac{\de_{i,j}}{D_{i,j}} \qifq i \neq j, \\
%          -\sum_{k} B(D)_{i,k} \qifq i = j.
% } \]

%%
% Initialize the positions for the algorithm.

Y = X/q;

%%
% Operator \(B\).

remove_diag = @(b)b - diag(sum(b));
B = @(D1)remove_diag( -delta./max(D1,1e-10) );

%%
% Update the positions.

Y = Y * B(D(Y))' / N;

%%
% _Exercice 3:_ (<../missing-exo/ check the solution>)
% Perform the SMACOF iterative algorithm.
% Save in a variable |s(l)| the values of
% Stress\(( X^{(\ell)} )\).

exo3;


%%
% Plot stress evolution during minimization.

clf;
plot(s, '.-', 'LineWidth', 2, 'MarkerSize', 20);
axis('tight');

%%
% Plot the optimized invariant shape.

clf;
h = plot(Y(2,[1:N0 1]), Y(1,[1:N0 1])); 
axis('ij'); axis('equal'); axis('off');
set(h, 'LineWidth', lw);


%% Shape Retrieval with Bending Invariant.
% One can compute a bending invariant signature for each shape in a library
% of images.

%%
% Isometry-invariant retrival is then perform by matching the invariant
% signature.

%%
% _Exercice 4:_ (<../missing-exo/ check the solution>)
% Implement a shape retrival algorithm based on these bending invariants.

exo4;


%% Bibliography
% <html><a name="biblio"></a></html>

%%
% * [EladKim03] A. Elad and R. Kimmel, <http://dx.doi.org/10.1109/TPAMI.2003.1233902 _On bending invariant signatures for surfaces_>, IEEE Transactions onPattern Analysis and Machine Intelligence, Vol. 25(10), p. 1285-1295, 2003.
% * [SchwShWolf89] E.L. Schwartz and A. Shaw and E. Wolfson, <http://dx.doi.org/10.1109/34.35506 _A Numerical Solution to the Generalized Mapmaker's Problem: Flattening Nonconvex Polyhedral Surfaces_>, IEEE Transactions on Pattern Analysis and Machine Intelligence, 11(9), p. 1005-1008, 1989.
% * [TenSolvLang03] J. B. Tenenbaum, V. de Silva and J. C. Langford, <http://dx.doi.org/10.1126/science.290.5500.2319 _A Global Geometric Framework for Nonlinear Dimensionality Reduction_>, Science 290 (5500): 2319-2323, 22 December 2000 
% * [Kruskal64] J. B. Kruskal, <http://dx.doi.org/10.1007/BF02289565 _Multidimensional scaling by optimizing goodness of fit to a nonmetric hypothesis_>, Psychometrika 29 (1): 1?27, 1964.
% * [Leeuw77] J. de Leeuw, <http://statistics.ucla.edu/preprints/uclastat-preprint-2005:35 _Applications of convex analysis to multidimensional scaling_>, in Recent developments in statistics, pp. 133?145, 1977
% * [BorgGroe97] I. Borg and P. Groenen, <http://www.springeronline.com/0-387-25150-2 _Modern Multidimensional Scaling: theory and applications_>, New York: Springer-Verlag, 1997.

##### SOURCE END #####
-->
   </body>
</html>