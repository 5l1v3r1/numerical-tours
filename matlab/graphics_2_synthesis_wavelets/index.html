
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Texture Synthesis Using Wavelets</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-20">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Texture Synthesis Using Wavelets</h1>
         <introduction>
            <p>This numerical tour explores texture synthesis using wavelets.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#9">Multi-scale Texture Synthesis</a></li>
               <li><a href="#20">Multi-scale Color Texture Synthesis</a></li>
               <li><a href="#24">Multi-dimensional Color Equalization</a></li>
            </ul>
         </div>
         <p>Image synthesis is obtained by drawing an image at random that satisfies some modeling constraint, that are usually learned
            from a given exemplar texture.
         </p>
         <h2>Installing toolboxes and setting up the path.<a name="2"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a> and <a href="../toolbox_general.zip">general toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt> and <tt>toolbox_general</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
</pre><h2>Multi-scale Texture Synthesis<a name="9"></a></h2>
         <p>The decay of wavelet coefficients caraterize pointwise singularities in images and texture. Histogram equalization enable
            the synthesis of texture with singularities. This corresponds to the texture synthesis algorithm of Heeger and Bergen.
         </p>
         <p>Load a texture.</p><pre class="codeinput">n = 512;
name = <span class="string">'texture'</span>;
M = load_image(name, n);
M = rescale( sum(M,3) );
</pre><p><b>For Scilab users</b>: you should increase the size of the memory. <i>Warning</i>: execute this line only once.
         </p><pre class="codeinput">extend_stack_size(4);
</pre><p>First we compute the wavelet coefficients of the texture. We use a translation invariant transform.</p><pre class="codeinput">options.ti = 1;
Jmin = 4;
MW = perform_wavelet_transf(M(:,:,1), Jmin, +1, options);
</pre><p>We initialize the synthesis by a random noise with the same gray values.</p><pre class="codeinput">M1 = perform_hist_eq(randn(n,n), M);
</pre><p>Display.</p><pre class="codeinput">clf;
imageplot(M, <span class="string">'Exemplar'</span>, 1,2,1);
imageplot(M1, <span class="string">'Initial noise'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_01.png"> <p>We also compute the wavelet transform of the noise.</p><pre class="codeinput">MW1 = perform_wavelet_transf(M1, Jmin, +1, options);
</pre><p>A random texture is obtained by histogram equalization of each wavelet scale.</p><pre class="codeinput"><span class="keyword">for</span> i=1:size(MW,3)
    MW1(:,:,i) = perform_hist_eq(MW1(:,:,i), MW(:,:,i));
<span class="keyword">end</span>
</pre><p>We retrieve the texture by inverse wavelet transform.</p><pre class="codeinput">M1 = perform_wavelet_transf(MW1, Jmin, -1, options);
</pre><p>Display.</p><pre class="codeinput">clf;
imageplot(M, <span class="string">'Exemplar'</span>, 1,2,1);
imageplot(M1, <span class="string">'Initial synthesis'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_02.png"> <p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Iterate these two steps (spatial and wavelet histogram matching) until convergence to a stable step.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_03.png"> <h2>Multi-scale Color Texture Synthesis<a name="20"></a></h2>
         <p>It is possible to perform color synthesis by synthesizing independantly each channel over a well chosen color space.</p>
         <p>Load a color texture.</p><pre class="codeinput">n = 512;
M = rescale( load_image(<span class="string">'texture'</span>, n) );
</pre><p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Perform color texture synthesis with wavelets over the RGB space.
         </p><pre class="codeinput">exo2;
</pre><img vspace="5" hspace="5" src="index_04.png"> <p><i>Exercice 3:</i> (<a href="../missing-exo/">check the solution</a>) Try with other color spaces, for instance PCA adapte space.
         </p><pre class="codeinput">exo3;
</pre><h2>Multi-dimensional Color Equalization<a name="24"></a></h2>
         <p>To maintain color consistency, it is possible to use a color equalization.</p>
         <p>Initial image.</p><pre class="codeinput">M1 = randn(n,n,3);
</pre><p>A simple (but not very acurate) method to perform in performing independant channel equalization over randomized color space.
            This needs to be repeated several time to converge to a real matching.
         </p>
         <p>Compute a random 3x3 orthogonal matrix.</p><pre class="codeinput">[U,R] = qr(randn(3));
</pre><p>Perform the change of color space.</p><pre class="codeinput">d = reshape(M,[n^2 3])*U;
d1 = reshape(M1,[n^2 3])*U;
</pre><p>Perform the equalization</p><pre class="codeinput"><span class="keyword">for</span> c=1:3
    d1(:,c) = perform_hist_eq(d1(:,c),d(:,c));
<span class="keyword">end</span>
</pre><p>Perform the inverse change of color space.</p><pre class="codeinput">M1 = reshape(d1*U',[n n 3]);
</pre><p>Compares the histogram of the R channel. You can see that the match is imperfect.</p><pre class="codeinput">m = M(:,:,1); m1 = M1(:,:,1);
clf;
subplot(2,1,1);
hist(m(:),50); title(<span class="string">'Original'</span>);
subplot(2,1,2);
hist(clamp(m1(:)),50); title(<span class="string">'Matched'</span>);

M1 = randn(n,n,3);
<span class="keyword">for</span> i=1:3
    M1(:,:,i) = perform_hist_eq(M1(:,:,i), M(:,:,i));
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_05.png"> <p><i>Exercice 4:</i> (<a href="../missing-exo/">check the solution</a>) Perform iteratively the randomized matching. Plot the decay of the mathing error.
         </p><pre class="codeinput">exo4;
</pre><img vspace="5" hspace="5" src="index_06.png"> <p>Display the histograms of the R channels. The match is not perfect, but it is better than with a single projection.</p><pre class="codeinput">m = M(:,:,1); m1 = M1(:,:,1);
clf;
subplot(2,1,1);
hist(m(:),50); title(<span class="string">'Original'</span>);
subplot(2,1,2);
hist(clamp(m1(:)),50); title(<span class="string">'Matched'</span>);
</pre><img vspace="5" hspace="5" src="index_07.png"> <p>Display the equalized color image;</p><pre class="codeinput">clf;
imageplot(M, <span class="string">'Image'</span>, 1,2,1);
imageplot(M1, <span class="string">'Equalized'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_08.png"> <p><i>Exercice 5:</i> (<a href="../missing-exo/">check the solution</a>) Perform color texture synthesis with wavelets using this color histogram matching at each iteration.
         </p><pre class="codeinput">exo5;
</pre><img vspace="5" hspace="5" src="index_09.png"> <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Texture Synthesis Using Wavelets
% This numerical tour explores texture synthesis using wavelets.

%%
% Image synthesis is obtained by drawing an image at random that satisfies
% some modeling constraint, that are usually learned from a given exemplar
% texture. 


%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox> and 
% <../toolbox_general.zip general toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal| and 
% |toolbox_general|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');


%% Multi-scale Texture Synthesis
% The decay of wavelet coefficients caraterize pointwise singularities in
% images and texture. Histogram equalization enable the synthesis of
% texture with singularities. This corresponds to the texture synthesis
% algorithm of Heeger and Bergen.

%%
% Load a texture.

n = 512;
name = 'texture';
M = load_image(name, n);
M = rescale( sum(M,3) );

%% 
% *For Scilab users*: you should increase the size of the memory.
% _Warning_: execute this line only once.

extend_stack_size(4);

%%
% First we compute the wavelet coefficients of the texture.
% We use a translation invariant transform.

options.ti = 1;
Jmin = 4;
MW = perform_wavelet_transf(M(:,:,1), Jmin, +1, options);

%%
% We initialize the synthesis by a random noise with the same gray values.

M1 = perform_hist_eq(randn(n,n), M);

%%
% Display.

clf;
imageplot(M, 'Exemplar', 1,2,1);
imageplot(M1, 'Initial noise', 1,2,2);

%% 
% We also compute the wavelet transform of the noise.

MW1 = perform_wavelet_transf(M1, Jmin, +1, options);

%%
% A random texture is obtained by histogram equalization of each wavelet
% scale.

for i=1:size(MW,3)
    MW1(:,:,i) = perform_hist_eq(MW1(:,:,i), MW(:,:,i));    
end

%%
% We retrieve the texture by inverse wavelet transform.

M1 = perform_wavelet_transf(MW1, Jmin, -1, options);

%%
% Display.

clf;
imageplot(M, 'Exemplar', 1,2,1);
imageplot(M1, 'Initial synthesis', 1,2,2);

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Iterate these two steps (spatial and wavelet histogram matching) until convergence to a stable step.

exo1;

%% Multi-scale Color Texture Synthesis
% It is possible to perform color synthesis by synthesizing independantly
% each channel over a well chosen color space.

%% 
% Load a color texture.

n = 512;
M = rescale( load_image('texture', n) );

%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Perform color texture synthesis with wavelets over the RGB space.

exo2;

%%
% _Exercice 3:_ (<../missing-exo/ check the solution>)
% Try with other color spaces, for instance PCA adapte space.

exo3;

%% Multi-dimensional Color Equalization
% To maintain color consistency, it is possible to use a color
% equalization.

%%
% Initial image.

M1 = randn(n,n,3);

%% 
% A simple (but not very acurate) method to perform in performing
% independant channel equalization over randomized color space. 
% This needs to be repeated several time to converge to a real matching.

%%
% Compute a random 3x3 orthogonal matrix.

[U,R] = qr(randn(3));

%%
% Perform the change of color space.

d = reshape(M,[n^2 3])*U;
d1 = reshape(M1,[n^2 3])*U;

%%
% Perform the equalization

for c=1:3
    d1(:,c) = perform_hist_eq(d1(:,c),d(:,c));
end

%%
% Perform the inverse change of color space.

M1 = reshape(d1*U',[n n 3]);

%%
% Compares the histogram of the R channel. You can see that the match is
% imperfect.

m = M(:,:,1); m1 = M1(:,:,1);
clf;
subplot(2,1,1);
hist(m(:),50); title('Original');
subplot(2,1,2);
hist(clamp(m1(:)),50); title('Matched'); 

M1 = randn(n,n,3);
for i=1:3
    M1(:,:,i) = perform_hist_eq(M1(:,:,i), M(:,:,i));
end

%%
% _Exercice 4:_ (<../missing-exo/ check the solution>)
% Perform iteratively the randomized matching. Plot the decay of the
% mathing error.

exo4;

%%
% Display the histograms of the R channels. The match is not perfect, 
% but it is better than with a single projection.

m = M(:,:,1); m1 = M1(:,:,1);
clf;
subplot(2,1,1);
hist(m(:),50); title('Original');
subplot(2,1,2);
hist(clamp(m1(:)),50); title('Matched');

%%
% Display the equalized color image;

clf;
imageplot(M, 'Image', 1,2,1);
imageplot(M1, 'Equalized', 1,2,2);

%%
% _Exercice 5:_ (<../missing-exo/ check the solution>)
% Perform color texture synthesis with wavelets using this color histogram
% matching at each iteration.

exo5;


##### SOURCE END #####
-->
   </body>
</html>