
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Color Image Denoising with Median Filtering</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-20">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Color Image Denoising with Median Filtering</h1>
         <introduction>
            <p>This numerical tour explores denoising of color images using a local multi-dimensional median. This is the sequel to the numerical
               tour <a href="../tv_median/"><i>Outliers and Median Denoiser</i></a>.
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Multidimensional Median</a></li>
               <li><a href="#19">Color Image Denoising using 1D Median</a></li>
               <li><a href="#26">Color Image Denoising using 3D Median</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a> and <a href="../toolbox_general.zip">general toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt> and <tt>toolbox_general</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
</pre><h2>Multidimensional Median<a name="8"></a></h2>
         <p>The median of <tt>n</tt> real values <tt>x</tt> is obtained by taking <tt>v(n/2)</tt> with <tt>v=sort(x)</tt> (with a special care for an even number <tt>n</tt>). It can alternatively obtained by minizing over <tt>y</tt> the sum of <i>absolute values</i>.
         </p><pre class="codeinput">|\sum_i abs(x(i)-y)|
</pre><p>This should be contrasted with the mean that minimizes the sum of <i>squares</i>.
         </p><pre class="codeinput">|\sum_i (x(i)-y)^2|
</pre><p>This allows one to define a mutidimensional median for set of points <tt>x(i)</tt> in dimension <tt>d</tt> by replacing <tt>abs</tt> by the d-dimensional norm.
         </p>
         <p>We define a Gaussian point cloud in 2D.</p><pre class="codeinput">d = 2; <span class="comment">% dimension</span>
n = 1000; <span class="comment">% number of points</span>
X = randn(d,n);
</pre><p>We modify some points as positive outliers (to shift the mean).</p><pre class="codeinput">p = 100; <span class="comment">% number of outliers</span>
sel = randperm(n); sel = sel(1:p); <span class="comment">% index of outliers</span>
X(:,sel) = rand(d,p)*50;
</pre><p>We can compute the mean point.</p><pre class="codeinput">m = mean(X,2);
</pre><p>To compute the median in 2D, one needs to minimize the sum of norms. This is not as straightforward as the sum of squares,
            since there is no close form solution. One needs to use an iterative algorithm, for instance the re-weighted least squares,
            that computes weighted means.
         </p><pre class="codeinput"><span class="comment">% number of iterations of the method</span>
niter = 30;
<span class="comment">% initialize the median using the mean</span>
med = m;
energy = [];
<span class="keyword">for</span> i=1:niter
    <span class="comment">% comute the distance from med to the points</span>
    dist = sqrt( sum( (X-repmat(med,[1 n])).^2 ) );
    <span class="comment">% compute the weight, take care of not dividing by 0</span>
    weight = 1./max( dist, 1e-10 ); weight = weight/sum(weight);
    <span class="comment">% compute the weighted mean</span>
    med = sum( repmat(weight,[d 1]).*X, 2 );
    energy(end+1) = sum( dist );
<span class="keyword">end</span>
</pre><p>We can display the decay of the L1 energy through the iterations.</p><pre class="codeinput">clf;
plot(energy, <span class="string">'.-'</span>); axis(<span class="string">'tight'</span>)
set_label(<span class="string">'Iteration'</span>, <span class="string">'L1 energy'</span>);
</pre><img vspace="5" hspace="5" src="index_01.png"> <p>We can display the points, the mean and the median.</p><pre class="codeinput">clf;
hold(<span class="string">'on'</span>);
plot(X(1,:), X(2,:), <span class="string">'.'</span>);
plot(m(1,:), m(2,:), <span class="string">'k*'</span>);
plot(med(1,:), med(2,:), <span class="string">'ro'</span>);
axis(<span class="string">'tight'</span>);
</pre><img vspace="5" hspace="5" src="index_02.png"> <h2>Color Image Denoising using 1D Median<a name="19"></a></h2>
         <p>A median filter can be used to denoise a color image, by applying it to each channel of the image.</p>
         <p>We load a color image, which is an array of size <tt>[n,n,3]</tt>.
         </p><pre class="codeinput">name = <span class="string">'flowers'</span>;
options.nbdims = 3;
n = 256;
M0 = load_image(name, n, options);
M0 = rescale(M0);
</pre><p>We create a colored impulse noise by taking two Gaussians of different standard deviations.</p><pre class="codeinput"><span class="comment">% percent of strong Gaussian</span>
rho = .4;
<span class="comment">% mask of pixel corrupted by strong gaussian</span>
mask = repmat(rand(n,n)&lt;rho, [1 1 3]);
<span class="comment">% deviation of the two Gaussian</span>
sigma1 = .03; sigma2 = 1;
<span class="comment">% noise with two different Gaussians</span>
noise = sigma1*randn(n,n,3).*(1-mask) + sigma2*rand(n,n,3).*mask;
</pre><p>Add the noise to the image.</p><pre class="codeinput">M = M0+noise;
pnoisy = snr(M0,M);
</pre><p>Display the clean and noisy images.</p><pre class="codeinput">clf;
imageplot(M0, <span class="string">'Clean image'</span>, 1,2,1);
imageplot(clamp(M), strcat([<span class="string">'Noisy, SNR='</span> num2str(pnoisy)]), 1,2,2 );
</pre><img vspace="5" hspace="5" src="index_03.png"> <p>In the following, we use a fixed window width.</p><pre class="codeinput">k = 4;
w = 2*k+1;
</pre><p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) A first way to denoise the image is to apply the local median filter implemented with the function <tt>perform_median_filtering</tt> on each channel <tt>M(:,:,i)</tt> of the image, to get a denoised image <tt>Mindep</tt> with SNR <tt>pindep</tt>.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_04.png"> <h2>Color Image Denoising using 3D Median<a name="26"></a></h2>
         <p>Another method computes a multidimensional median for patches located around each pixel of the image.</p>
         <p>First we extract the 3D points corresponding to the colors in the patch located around a pixel at a location <tt>(x,y)</tt>.
         </p><pre class="codeinput"><span class="comment">% example of pixel location</span>
x = 100; y = 73;
<span class="comment">% location of the patch, with pediodic boundary condition</span>
selx = x-k:x+k; selx = mod(selx-1,n)+1;
sely = y-k:y+k; sely = mod(sely-1,n)+1;
<span class="comment">% extract the patch</span>
patch = M(selx,sely,:);
<span class="comment">% patch of pixels, stored as a matrix</span>
X = reshape( patch, [w*w 3])';
</pre><p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Compute the median <tt>med</tt> of the points in <tt>X</tt> using the iterative reweighted least squares algorithm. This computed median <tt>med</tt> should be stored in the result as <tt>Mmed(x,y,:)</tt> (you need to reshape <tt>med</tt> so that its size is <tt>[1 1 3]</tt>).
         </p><pre class="codeinput">exo2;
</pre><p>We can display the points, the mean and the median, in 3D.</p><pre class="codeinput">m = mean(X, 2);
clf;
hold(<span class="string">'on'</span>);
plot3(X(1,:), X(2,:), X(3,:), <span class="string">'.'</span>);
plot3(m(1), m(2), m(3), <span class="string">'*k'</span>);
plot3(med(1), med(2), med(3), <span class="string">'or'</span>);
view(3); axis(<span class="string">'tight'</span>);
</pre><img vspace="5" hspace="5" src="index_05.png"> <p><i>Exercice 3:</i> (<a href="../missing-exo/">check the solution</a>) Implement the 3D median filter by looping through all the pixel <tt>(x,y)</tt>.
         </p><pre class="codeinput">exo3;
</pre><img vspace="5" hspace="5" src="index_06.png"> <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Color Image Denoising with Median Filtering
% This numerical tour explores denoising of color images using a local
% multi-dimensional median. This is the sequel to the numerical tour 
% <../tv_median/ _Outliers and Median Denoiser_>.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox> and 
% <../toolbox_general.zip general toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal| and 
% |toolbox_general|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');


%% Multidimensional Median
% The median of |n| real values |x| is obtained by taking |v(n/2)| with
% |v=sort(x)| (with a special care for an even number |n|).
% It can alternatively obtained by minizing over |y| the sum of _absolute
% values_.

%%
%   |\sum_i abs(x(i)-y)|

%%
% This should be contrasted with the mean that minimizes the sum of
% _squares_.

%%
%   |\sum_i (x(i)-y)^2|

%%
% This allows one to define a mutidimensional median for set of points |x(i)| in
% dimension |d| by replacing |abs| by the d-dimensional norm.

%% 
% We define a Gaussian point cloud in 2D.

d = 2; % dimension
n = 1000; % number of points
X = randn(d,n);

%%
% We modify some points as positive outliers (to shift the mean).

p = 100; % number of outliers
sel = randperm(n); sel = sel(1:p); % index of outliers
X(:,sel) = rand(d,p)*50;

%%
% We can compute the mean point.

m = mean(X,2);

%%
% To compute the median in 2D, one needs to minimize the sum of norms. 
% This is not as straightforward as the sum of squares, since there
% is no close form solution. One needs to use an iterative algorithm, for
% instance the re-weighted least squares, that computes weighted means.

% number of iterations of the method
niter = 30;
% initialize the median using the mean
med = m;
energy = [];
for i=1:niter
    % comute the distance from med to the points
    dist = sqrt( sum( (X-repmat(med,[1 n])).^2 ) );
    % compute the weight, take care of not dividing by 0
    weight = 1./max( dist, 1e-10 ); weight = weight/sum(weight);
    % compute the weighted mean
    med = sum( repmat(weight,[d 1]).*X, 2 );
    energy(end+1) = sum( dist );
end

%%
% We can display the decay of the L1 energy through the iterations.

clf;
plot(energy, '.-'); axis('tight')
set_label('Iteration', 'L1 energy');

%%
% We can display the points, the mean and the median.

clf;
hold('on');
plot(X(1,:), X(2,:), '.');
plot(m(1,:), m(2,:), 'k*');
plot(med(1,:), med(2,:), 'ro');
axis('tight');

%% Color Image Denoising using 1D Median
% A median filter can be used to denoise a color image, by applying it to each channel of the image.

%%
% We load a color image, which is an array of size |[n,n,3]|.

name = 'flowers';
options.nbdims = 3;
n = 256;
M0 = load_image(name, n, options);
M0 = rescale(M0);

%%
% We create a colored impulse noise by taking two Gaussians of different
% standard deviations.

% percent of strong Gaussian
rho = .4;
% mask of pixel corrupted by strong gaussian
mask = repmat(rand(n,n)<rho, [1 1 3]);
% deviation of the two Gaussian
sigma1 = .03; sigma2 = 1;
% noise with two different Gaussians
noise = sigma1*randn(n,n,3).*(1-mask) + sigma2*rand(n,n,3).*mask;

%%
% Add the noise to the image.

M = M0+noise;
pnoisy = snr(M0,M);

%%
% Display the clean and noisy images.

clf;
imageplot(M0, 'Clean image', 1,2,1);
imageplot(clamp(M), strcat(['Noisy, SNR=' num2str(pnoisy)]), 1,2,2 );

%%
% In the following, we use a fixed window width.

k = 4;
w = 2*k+1;

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% A first way to denoise the image is to apply the local median filter 
% implemented with the function |perform_median_filtering| on
% each channel |M(:,:,i)| of the image, to get a denoised image |Mindep| with SNR |pindep|.

exo1;

%% Color Image Denoising using 3D Median
% Another method computes a multidimensional median for patches located
% around each pixel of the image.

%%
% First we extract the 3D points corresponding to the colors in the patch located around a pixel 
% at a location |(x,y)|.

% example of pixel location
x = 100; y = 73;
% location of the patch, with pediodic boundary condition
selx = x-k:x+k; selx = mod(selx-1,n)+1;
sely = y-k:y+k; sely = mod(sely-1,n)+1;
% extract the patch
patch = M(selx,sely,:);
% patch of pixels, stored as a matrix
X = reshape( patch, [w*w 3])';

%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Compute the median |med| of the points in |X| 
% using the iterative reweighted least squares algorithm.
% This computed median |med| should be stored in the result as
% |Mmed(x,y,:)| (you need to reshape |med| so that its size is |[1 1 3]|).

exo2;


%%
% We can display the points, the mean and the median, in 3D.

m = mean(X, 2);
clf;
hold('on');
plot3(X(1,:), X(2,:), X(3,:), '.');
plot3(m(1), m(2), m(3), '*k');
plot3(med(1), med(2), med(3), 'or');
view(3); axis('tight');

%%
% _Exercice 3:_ (<../missing-exo/ check the solution>)
% Implement the 3D median filter by looping through all the pixel |(x,y)|.

exo3;

##### SOURCE END #####
-->
   </body>
</html>