
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Geodesic Bending Invariants for Surfaces</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-21">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Geodesic Bending Invariants for Surfaces</h1>
         <introduction>
            <p>This tour explores the computation of bending invariants of surfaces.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Bending Invariants</a></li>
               <li><a href="#14">3-D Surfaces and Geodesic Distances</a></li>
               <li><a href="#22">Bending Invariant with Strain Minimization</a></li>
               <li><a href="#29">Bending Invariant with Stress Minimization</a></li>
               <li><a href="#39">Surface Retrieval with Bending Invariant.</a></li>
               <li><a href="#42">Bibliography</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a>, <a href="../toolbox_general.zip">general toolbox</a> and <a href="../toolbox_graph.zip">graph toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt>, <tt>toolbox_general</tt> and <tt>toolbox_graph</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
getd(<span class="string">'toolbox_graph/'</span>);
</pre><h2>Bending Invariants<a name="8"></a></h2>
         <p>Bending invariants replace the position of the vertices in a shape \(\Ss\) (2-D or 3-D) by new positions that are insensitive
            to isometric deformation of the shape. This defines a bending invariant signature that can be used for surface matching.
         </p>
         <p>Bending invariant were introduced in <a href="#biblio">[EladKim03]</a>. A related method was developped for brain flattening in <a href="#biblio">[SchwShWolf89]</a>. This method is related to the Isomap algorithm for manifold learning <a href="#biblio">[TenSolvLang03]</a>.
         </p>
         <p>We assume that \(Ss\) has some Riemannian metric, for instance coming from the embedding of a surface in 3-D Euclidian space,
            or by restriction of the Euclian 2-D space to a 2-D sub-domain (planar shape). One thus can compute the geodesic distance
            \(d(x,x')\) between points \(x,x' \in \Ss\).
         </p>
         <p>The bending invariant \(\tilde \Ss\) of \(\Ss\) is defined as the set of points \(Y = (y_i)_j \subset \RR^d\) that are optimized
            so that the Euclidean distance between points in \(Y\) matches as closely the geodesic distance between points in \(X\), i.e.
            \[ \forall i, j, \quad \norm{y_i-y_j} \approx d(x_i,x_j) \]
         </p>
         <p>Multi-dimensional scaling (MDS) is a class of method that aims at computing such a set of points \(Y \in \RR^{d \times N}\)
            in \(\RR^d\) such that \[ \forall i, j, \quad \norm{y_i-y_j} \approx \de_{i,j} \] where \(\de \in \RR^{N \times N}\) is a
            input data matrix. For a detailed overview of MDS, we refer to the book <a href="#biblio">[BorgGroe97]</a></p>
         <p>In this tour, we apply two specific MDS algorithms (strain and stress minimization) with input \(\de_{i,j} = d(x_i,x_j)\).</p>
         <h2>3-D Surfaces and Geodesic Distances<a name="14"></a></h2>
         <p>We consider here a syrface \(\Ss \subset \RR^3\).</p>
         <p>Load a mesh of \(N\) vertices that discretizes this surfaces.</p><pre class="codeinput">name = <span class="string">'camel'</span>;
options.name = name;
[V,F] = read_mesh(name);
N = size(V,2);
</pre><p>Display it.</p><pre class="codeinput">clf;
plot_mesh(V,F, options);
</pre><img vspace="5" hspace="5" src="index_01.png"> <p>The geodesic distance map \(U(x) = d(x,x_i)\) to a starting point \(x_i\) can be computed in \(O(N \log(N))\) operations on
            a mesh of \(N\) vertices using the Fast Marching algorithm.
         </p><pre class="codeinput">i = 1;
U = perform_fast_marching_mesh(V, F, i);
</pre><p>Extract a bunch of geodesic shortest paths from \(x_i\) to randomly selected vertices \( (x_j)_{j \in J} \).</p><pre class="codeinput">options.method = <span class="string">'continuous'</span>;
J = randperm(N); J = J(1:50);
paths = compute_geodesic_mesh(U, V, F, J, options);
</pre><p>Display the distance \(U\) on the 3-D mesh together with the geodesic paths.</p><pre class="codeinput">clf;
plot_fast_marching_mesh(V, F, U, paths, options);
</pre><img vspace="5" hspace="5" src="index_02.png"> <p>The geodesic distance matrix \(\de \in \RR^{N \times N}\) is defined as \[ \forall i,j=1,\ldots,N, \quad       \de_{i,j} =
            d(x_i,x_j). \]
         </p>
         <p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Compute the geodesic distance matrix \(\de\). It is going to take some of time.
         </p><pre class="codeinput">exo1;
</pre><h2>Bending Invariant with Strain Minimization<a name="22"></a></h2>
         <p>The goal is to compute a set of points \(Y = (y_i)_{i=1}^N\) in \(\RR^d\), (here we use \(d=2\)) stored in a matrix \(Y \in
            \RR^{d \times N}\) such that \[ \forall i, j, \quad D^2(Y)_{i,j} \approx \de_{i,j}^2   \qwhereq  D^2(Y)_{i,j} = \norm{y_i-y_j}^2.
            \]
         </p>
         <p>Target dimensionality \(d\).</p><pre class="codeinput">d = 3;
</pre><p>This can be achieved by minimzing a \(L^2\) loss \[ \umin{Y} \norm{ D^2(Y)-\de^2 }^2 =       \sum_{i&lt;j} \abs{ \norm{y_i-y_j}^2
            - \de_{i,j}^2 }^2. \]
         </p>
         <p>Strain minimization consider instead the following weighted \(L^2\) loss (so-called strain) \[ \umin{Y \in \RR^{d \times N}
            } \text{Strain}(Y)       = \norm{ J ( D^2(Y)-\de^2 ) J }^2 \] where \(J\) is the so-called centering matrix \[ J_{i,j} = 
                 \choice{           1-1/N \qifq i=j, \\           -1/N \qifq i \neq j.  }\]
         </p><pre class="codeinput">J = eye(N) - ones(N)/N;
</pre><p>Using the properties of squared-distance matrices \(D^2(Y)\), one can show that \[ \norm{ J ( D^2(Y)-\de^2 ) J }^2 =   \norm{
            Y Y^* - K }^2   \qwhereq K = - \frac{1}{2} J \de^2 J. \]
         </p><pre class="codeinput">K = -1/2 * J*(delta.^2)*J;
</pre><p>The solution to this (non-convex) optimization problem can be computed exactly as the rows of \(Y\) being the two leading
            eigenvectors of \(K\) propery rescaled.
         </p><pre class="codeinput">opt.disp = 0;
[Y, v] = eigs(K, d, <span class="string">'LR'</span>, opt);
Y = Y .* repmat(sqrt(diag(v))', [N 1]);
Y = Y';
</pre><p>Display the bending invariant surface.</p><pre class="codeinput">clf;
plot_mesh(Y,F, options);
</pre><img vspace="5" hspace="5" src="index_03.png"> <h2>Bending Invariant with Stress Minimization<a name="29"></a></h2>
         <p>The stress functional does not have geometrical meaning. An alternative MDS method directly minimizes a geometric loss, the
            so-called Stress \[ \umin{Y \in \RR^{d \times N} } \text{Stress}(Y) =       \norm{ D(Y)-\de }^2 =       \sum_{i&lt;j} \abs{ \norm{y_i-y_j}
            - \de_{i,j} }^2.  \] It is possible to find a local minimizer of this energy by various descent algorithms, as initially proposed
            by <a href="#biblio">[Kruskal64]</a></p><pre class="codeinput">Stress = @(d)sqrt( sum( abs(delta(:)-d(:)).^2 ) / N^2 );
</pre><p>Operator to compute the distance matrix \(D(Y)\).</p><pre class="codeinput">D = @(Y)sqrt( repmat(sum(Y.^2),N,1) + repmat(sum(Y.^2),N,1)' - 2*Y'*Y);
</pre><p>The SMACOF (Scaling by majorizing a convex function) algorithm solves at each iterations a quadratic energy, that is guaranteed
            to diminish the value of the Strain. It was introduced by <a href="#biblio">[Leeuw77]</a></p>
         <p>It computes iterates \(X^{(\ell)}\) as \[ X^{(\ell+1)} = \frac{1}{N} X^{(\ell)} B(D(X^{(\ell)}))^*,  \] where \[ B(D) = \choice{
                     -\frac{\de_{i,j}}{D_{i,j}} \qifq i \neq j, \\          -\sum_{k} B(D)_{i,k} \qifq i = j. } \]
         </p>
         <p>Initialize the positions for the algorithm.</p><pre class="codeinput">Y = V;
</pre><p>Operator \(B\).</p><pre class="codeinput">remove_diag = @(b)b - diag(sum(b));
B = @(D1)remove_diag( -delta./max(D1,1e-10) );
</pre><p>Update the positions.</p><pre class="codeinput">Y = Y * B(D(Y))' / N;
</pre><p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Perform the SMACOF iterative algorithm. Save in a variable <tt>s(l)</tt> the values of Stress\(( X^{(\ell)} )\).
         </p><pre class="codeinput">exo2;
</pre><img vspace="5" hspace="5" src="index_04.png"> <p>Plot stress evolution during minimization.</p><pre class="codeinput">clf;
plot(s, <span class="string">'.-'</span>, <span class="string">'LineWidth'</span>, 2, <span class="string">'MarkerSize'</span>, 20);
axis(<span class="string">'tight'</span>);
</pre><img vspace="5" hspace="5" src="index_05.png"> <p>Plot the optimized invariant shape.</p><pre class="codeinput">clf;
plot_mesh(Y,F, options);
</pre><img vspace="5" hspace="5" src="index_06.png"> <h2>Surface Retrieval with Bending Invariant.<a name="39"></a></h2>
         <p>One can compute a bending invariant signature for each mesh in a library of 3D surface.</p>
         <p>Isometry-invariant retrival is then perform by matching the invariant signature.</p>
         <p><i>Exercice 3:</i> (<a href="../missing-exo/">check the solution</a>) Implement a surface retrival algorithm based on these bending invariants.
         </p><pre class="codeinput">exo3;
</pre><h2>Bibliography<a name="42"></a></h2>
         <p><a name="biblio"></a></p>
         <div>
            <ul>
               <li>[EladKim03]&nbsp;A. Elad and R. Kimmel, <a href="http://dx.doi.org/10.1109/TPAMI.2003.1233902"><i>On bending invariant signatures for surfaces</i></a>, IEEE Transactions onPattern Analysis and Machine Intelligence, Vol. 25(10), p. 1285-1295, 2003.
               </li>
               <li>[SchwShWolf89] E.L. Schwartz and A. Shaw and E. Wolfson, <a href="http://dx.doi.org/10.1109/34.35506"><i>A Numerical Solution to the Generalized Mapmaker's Problem: Flattening Nonconvex Polyhedral Surfaces</i></a>, IEEE Transactions on Pattern Analysis and Machine Intelligence, 11(9), p. 1005-1008, 1989.
               </li>
               <li>[TenSolvLang03] J. B. Tenenbaum, V. de Silva and J. C. Langford, <a href="http://dx.doi.org/10.1126/science.290.5500.2319"><i>A Global Geometric Framework for Nonlinear Dimensionality Reduction</i></a>, Science 290 (5500): 2319-2323, 22 December 2000
               </li>
               <li>[Kruskal64] J. B. Kruskal, <a href="http://dx.doi.org/10.1007/BF02289565"><i>Multidimensional scaling by optimizing goodness of fit to a nonmetric hypothesis</i></a>, Psychometrika 29 (1): 1?27, 1964.
               </li>
               <li>[Leeuw77] J. de Leeuw, <a href="http://statistics.ucla.edu/preprints/uclastat-preprint-2005:35"><i>Applications of convex analysis to multidimensional scaling</i></a>, in Recent developments in statistics, pp. 133?145, 1977
               </li>
               <li>[BorgGroe97] I. Borg and P. Groenen, <a href="http://www.springeronline.com/0-387-25150-2"><i>Modern Multidimensional Scaling: theory and applications</i></a>, New York: Springer-Verlag, 1997.
               </li>
            </ul>
         </div>
         <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Geodesic Bending Invariants for Surfaces
% This tour explores the computation of bending invariants of surfaces.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox>, 
% <../toolbox_general.zip general toolbox> and 
% <../toolbox_graph.zip graph toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal|, 
% |toolbox_general| and 
% |toolbox_graph|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');
getd('toolbox_graph/');


%% Bending Invariants
% Bending invariants replace the position of the vertices in a shape \(\Ss\) (2-D or 3-D)
% by new positions that are insensitive to isometric deformation of the shape.
% This defines a bending invariant signature that can be used for surface
% matching.
  
%% 
% Bending invariant were introduced in <#biblio [EladKim03]>.
% A related method was developped for brain flattening in <#biblio [SchwShWolf89]>.
% This method is related to the Isomap algorithm for manifold learning
% <#biblio [TenSolvLang03]>.

%% 
% We assume that \(Ss\) has some Riemannian metric, for instance coming
% from the embedding of a surface in 3-D Euclidian space, or by restriction of 
% the Euclian 2-D space to a 2-D sub-domain (planar shape). One thus can
% compute the geodesic distance \(d(x,x')\) between points \(x,x' \in
% \Ss\).

%%
% The bending invariant \(\tilde \Ss\) of \(\Ss\) is defined as the set of
% points \(Y = (y_i)_j \subset \RR^d\) that are optimized so that the Euclidean
% distance between points in \(Y\) matches as closely the geodesic distance
% between points in \(X\), i.e.
% \[ \forall i, j, \quad \norm{y_i-y_j} \approx d(x_i,x_j) \]

%%
% Multi-dimensional scaling (MDS) is a class of method that aims at
% computing such a set of points \(Y \in \RR^{d \times N}\) in \(\RR^d\)
% such that 
% \[ \forall i, j, \quad \norm{y_i-y_j} \approx \de_{i,j} \]
% where \(\de \in \RR^{N \times N}\) is a input data matrix. 
% For a detailed overview of MDS, we refer to the book <#biblio [BorgGroe97]>

%%
% In this tour, we apply two specific MDS algorithms (strain and stress
% minimization) with input \(\de_{i,j} = d(x_i,x_j)\).

%% 3-D Surfaces and Geodesic Distances
% We consider here a syrface \(\Ss \subset \RR^3\).

%%
% Load a mesh of \(N\) vertices that discretizes this surfaces.

name = 'camel';
options.name = name;
[V,F] = read_mesh(name);
N = size(V,2);

%%
% Display it.

clf;
plot_mesh(V,F, options);


%%
% The geodesic distance map \(U(x) = d(x,x_i)\) to a starting point \(x_i\)
% can be computed in \(O(N \log(N))\) operations on a mesh of \(N\) 
% vertices using the Fast Marching algorithm.

i = 1;
U = perform_fast_marching_mesh(V, F, i);

%%
% Extract a bunch of geodesic shortest paths from \(x_i\) 
% to randomly selected vertices \( (x_j)_{j \in J} \).

options.method = 'continuous';
J = randperm(N); J = J(1:50);
paths = compute_geodesic_mesh(U, V, F, J, options);

%% 
% Display the distance \(U\) on the 3-D mesh
% together with the geodesic paths.

clf;
plot_fast_marching_mesh(V, F, U, paths, options);

%%
% The geodesic distance matrix \(\de \in \RR^{N \times N}\) is defined as
% \[ \forall i,j=1,\ldots,N, \quad
%       \de_{i,j} = d(x_i,x_j). \]

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Compute the geodesic distance matrix \(\de\).
% It is going to take some of time.

exo1;


%% Bending Invariant with Strain Minimization
% The goal is to compute a set of points \(Y = (y_i)_{i=1}^N\) in
% \(\RR^d\), (here we use \(d=2\)) stored in a matrix \(Y \in \RR^{d \times N}\)
% such that
% \[ \forall i, j, \quad D^2(Y)_{i,j} \approx \de_{i,j}^2 
%   \qwhereq  D^2(Y)_{i,j} = \norm{y_i-y_j}^2. \]

%%
% Target dimensionality \(d\).

d = 3;

%%
% This can be achieved by minimzing a \(L^2\) loss
% \[ \umin{Y} \norm{ D^2(Y)-\de^2 }^2 = 
%       \sum_{i<j} \abs{ \norm{y_i-y_j}^2 - \de_{i,j}^2 }^2. \]

%%
% Strain minimization consider instead the following weighted \(L^2\) loss
% (so-called strain)
% \[ \umin{Y \in \RR^{d \times N} } \text{Strain}(Y) 
%       = \norm{ J ( D^2(Y)-\de^2 ) J }^2
% \]
% where \(J\) is the so-called centering matrix
% \[ J_{i,j} = 
%       \choice{
%           1-1/N \qifq i=j, \\
%           -1/N \qifq i \neq j.
%  }\]

J = eye(N) - ones(N)/N;

%%
% Using the properties of squared-distance matrices \(D^2(Y)\), one can
% show that 
% \[ \norm{ J ( D^2(Y)-\de^2 ) J }^2 = 
%   \norm{ Y Y^* - K }^2 
%   \qwhereq K = - \frac{1}{2} J \de^2 J. \]

K = -1/2 * J*(delta.^2)*J;

%%
% The solution to this (non-convex) optimization problem can be computed
% exactly as the rows of \(Y\) being the two leading eigenvectors of \(K\)
% propery rescaled.

opt.disp = 0; 
[Y, v] = eigs(K, d, 'LR', opt);
Y = Y .* repmat(sqrt(diag(v))', [N 1]);
Y = Y';

%%
% Display the bending invariant surface.

clf;
plot_mesh(Y,F, options);



%% Bending Invariant with Stress Minimization
% The stress functional does not have geometrical meaning. 
% An alternative MDS method directly minimizes a geometric loss, the
% so-called Stress
% \[ \umin{Y \in \RR^{d \times N} } \text{Stress}(Y) = 
%       \norm{ D(Y)-\de }^2 = 
%       \sum_{i<j} \abs{ \norm{y_i-y_j} - \de_{i,j} }^2. 
%  \]
% It is possible to find a local minimizer of this energy by various
% descent algorithms, as initially proposed by <#biblio [Kruskal64]>

Stress = @(d)sqrt( sum( abs(delta(:)-d(:)).^2 ) / N^2 ); 

%%
% Operator to compute the distance matrix \(D(Y)\).

D = @(Y)sqrt( repmat(sum(Y.^2),N,1) + repmat(sum(Y.^2),N,1)' - 2*Y'*Y);

%%
% The SMACOF (Scaling by majorizing a convex function) algorithm 
% solves at each iterations a quadratic energy, that is guaranteed to 
% diminish the value of the Strain. It was introduced by <#biblio [Leeuw77]>

%%
% It computes iterates \(X^{(\ell)}\) as
% \[ X^{(\ell+1)} = \frac{1}{N} X^{(\ell)} B(D(X^{(\ell)}))^*,  \]
% where 
% \[ B(D) = \choice{
%          -\frac{\de_{i,j}}{D_{i,j}} \qifq i \neq j, \\
%          -\sum_{k} B(D)_{i,k} \qifq i = j.
% } \]

%%
% Initialize the positions for the algorithm.

Y = V;

%%
% Operator \(B\).

remove_diag = @(b)b - diag(sum(b));
B = @(D1)remove_diag( -delta./max(D1,1e-10) );

%%
% Update the positions.

Y = Y * B(D(Y))' / N;

%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Perform the SMACOF iterative algorithm.
% Save in a variable |s(l)| the values of
% Stress\(( X^{(\ell)} )\).

exo2;

%%
% Plot stress evolution during minimization.

clf;
plot(s, '.-', 'LineWidth', 2, 'MarkerSize', 20);
axis('tight');

%%
% Plot the optimized invariant shape.

clf;        
plot_mesh(Y,F, options);

%% Surface Retrieval with Bending Invariant.
% One can compute a bending invariant signature for each mesh in a library
% of 3D surface.

%%
% Isometry-invariant retrival is then perform by matching the invariant
% signature.

%%
% _Exercice 3:_ (<../missing-exo/ check the solution>)
% Implement a surface retrival algorithm based on these bending invariants.

exo3;



%% Bibliography
% <html><a name="biblio"></a></html>

%%
% * [EladKim03] A. Elad and R. Kimmel, <http://dx.doi.org/10.1109/TPAMI.2003.1233902 _On bending invariant signatures for surfaces_>, IEEE Transactions onPattern Analysis and Machine Intelligence, Vol. 25(10), p. 1285-1295, 2003.
% * [SchwShWolf89] E.L. Schwartz and A. Shaw and E. Wolfson, <http://dx.doi.org/10.1109/34.35506 _A Numerical Solution to the Generalized Mapmaker's Problem: Flattening Nonconvex Polyhedral Surfaces_>, IEEE Transactions on Pattern Analysis and Machine Intelligence, 11(9), p. 1005-1008, 1989.
% * [TenSolvLang03] J. B. Tenenbaum, V. de Silva and J. C. Langford, <http://dx.doi.org/10.1126/science.290.5500.2319 _A Global Geometric Framework for Nonlinear Dimensionality Reduction_>, Science 290 (5500): 2319-2323, 22 December 2000 
% * [Kruskal64] J. B. Kruskal, <http://dx.doi.org/10.1007/BF02289565 _Multidimensional scaling by optimizing goodness of fit to a nonmetric hypothesis_>, Psychometrika 29 (1): 1?27, 1964.
% * [Leeuw77] J. de Leeuw, <http://statistics.ucla.edu/preprints/uclastat-preprint-2005:35 _Applications of convex analysis to multidimensional scaling_>, in Recent developments in statistics, pp. 133?145, 1977
% * [BorgGroe97] I. Borg and P. Groenen, <http://www.springeronline.com/0-387-25150-2 _Modern Multidimensional Scaling: theory and applications_>, New York: Springer-Verlag, 1997.


##### SOURCE END #####
-->
   </body>
</html>