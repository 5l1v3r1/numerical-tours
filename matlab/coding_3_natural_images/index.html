
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Natural Images Statistics</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-20">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Natural Images Statistics</h1>
         <introduction>
            <p>This numerical tour studies the statistics of natural images and their multiscale decomposition.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Histogram of Images and Equalization</a></li>
               <li><a href="#12">Statistics of the Wavelets Coefficients of Natural Images</a></li>
               <li><a href="#16">Higher Order Statistics</a></li>
               <li><a href="#22">Conditional coding</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a> and <a href="../toolbox_general.zip">general toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt> and <tt>toolbox_general</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
</pre><h2>Histogram of Images and Equalization<a name="8"></a></h2>
         <p>The histogram of an image describes its gray-level repartition.</p>
         <p>Load two images.</p><pre class="codeinput">n = 256;
M1 = rescale( load_image(<span class="string">'boat'</span>, n) );
M2 = rescale( load_image(<span class="string">'lena'</span>, n) );
</pre><p>Display the images and its histograms.</p><pre class="codeinput">clf;
subplot(2,2,1);
imageplot(M1);
subplot(2,2,2);
[h,t] = hist(M1(:), 60);
bar(t, h/sum(h));
axis(<span class="string">'square'</span>);
subplot(2,2,3);
imageplot(M2);
subplot(2,2,4);
[h,t] = hist(M2(:), 60);
bar(t, h/sum(h));
axis(<span class="string">'square'</span>);
</pre><img vspace="5" hspace="5" src="index_01.png"> <p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Histogram equalization is an orthogonal projector that maps the values of one signal onto the values of the other signal.
            This is achieved by assiging the sorted of ont signal to the sorted values of the other signla. Implement this for the two
            images.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_02.png"> <h2>Statistics of the Wavelets Coefficients of Natural Images<a name="12"></a></h2>
         <p>Although the histograms of images are flat, the histogram of their wavelet coefficients are usually highly picked at zero,
            resulting in a low entropy.
         </p>
         <p>Load an image.</p><pre class="codeinput">n = 256*2;
M = rescale( load_image(<span class="string">'lena'</span>, n) );
</pre><p>Compute its wavelet coefficients.</p><pre class="codeinput">Jmin = 4;
MW = perform_wavelet_transf(M,Jmin, +1);
</pre><p>Extract the fine horizontal details and display histograms. Take care at computing a centered histogram.</p><pre class="codeinput"><span class="comment">% extract the vertical details</span>
MW1 = MW(1:n/2,n/2+1:n);
<span class="comment">% compute histogram</span>
v = max(abs(MW1(:)));
k = 20;
t = linspace(-v,v,2*k+1);
h = hist(MW1(:), t);
<span class="comment">% display</span>
clf;
subplot(1,2,1);
imageplot(MW1);
subplot(1,2,2);
bar(t, h/sum(h)); axis(<span class="string">'tight'</span>);
axis(<span class="string">'square'</span>);
</pre><img vspace="5" hspace="5" src="index_03.png"> <h2>Higher Order Statistics<a name="16"></a></h2>
         <p>In order to analyse higher order statistics, one needs to consider couples of wavelet coefficients. For instance, we can consider
            the joint distribution of a coefficient and of one of its neighbors. The interesting quantities are the joint histogram and
            the conditional histogram (normalized so that row sum to 1).
         </p>
         <p>Compute quantized wavelet coefficients.</p><pre class="codeinput">T = .03;
MW1q = floor(abs(MW1/T)).*sign(MW1);
nj = size(MW1,1);
</pre><p>Compute the neighbors coefficients.</p><pre class="codeinput"><span class="comment">% spacial shift</span>
t = 2; <span class="comment">% you can try with other values</span>
C = reshape(MW1q([ones(1,t) 1:nj-t],:),size(MW1));
</pre><p>Compute the conditional histogram.</p><pre class="codeinput">options.normalize = 1;
[H,x,xc] = compute_conditional_histogram(MW1q,C, options);
</pre><p>Display.</p><pre class="codeinput">q = 8; <span class="comment">% width for display</span>
H = H((end+1)/2-q:(end+1)/2+q,(end+1)/2-q:(end+1)/2+q);
clf;
imagesc(-q:q,-q:q,max(log(H), -5)); axis <span class="string">image</span>;
colormap <span class="string">gray(256)</span>;
</pre><img vspace="5" hspace="5" src="index_04.png"> <p>Compute and display joint distribution.</p><pre class="codeinput">options.normalize = 0;
[H,x,xc] = compute_conditional_histogram(MW1q,C, options);
H = H((end+1)/2-q:(end+1)/2+q,(end+1)/2-q:(end+1)/2+q);
<span class="comment">% display level sets</span>
clf;
contour(-q:q,-q:q,max(log(H), -5), 20, <span class="string">'k'</span>); axis <span class="string">image</span>;
colormap <span class="string">gray(256)</span>;
</pre><img vspace="5" hspace="5" src="index_05.png"> <h2>Conditional coding<a name="22"></a></h2>
         <p>Since the neighboring coefficients are typically un-correlated but dependant, one can use this dependancy to build a conditional
            coder. In essence, it amouts to using several coder, and coding a coefficient with the coder that corresponds to the neighbooring
            value. Here we consider 3 coder (depending on the sign of the neighbor).
         </p>
         <p>Compute the contexts of the coder, this is the sign of the neighbor.</p><pre class="codeinput">C = sign( reshape(MW1q([1 1:nj-1],:),size(MW1)) );
</pre><p>Compute the conditional histogram</p><pre class="codeinput">[H,x,xc] = compute_conditional_histogram(MW1q,C);
</pre><p>Display the curve of the histogram</p><pre class="codeinput">clf; plot(x,H, <span class="string">'.-'</span>);
axis([-10 10 0 max(H(:))]);
legend(<span class="string">'sign=-1'</span>, <span class="string">'sign=0'</span>, <span class="string">'sign=+1'</span>);
set_graphic_sizes([], 20);
</pre><img vspace="5" hspace="5" src="index_06.png"> <p>Compare the entropy with/without coder.</p><pre class="codeinput"><span class="comment">% global entropy (without context)</span>
ent_total = compute_entropy(MW1q);
<span class="comment">% compute the weighted entropy of this context coder</span>
h0 = compute_histogram(C);
H(H==0) = 1e-9; <span class="comment">% avoid numerical problems</span>
ent_partial = sum( -log2(H).*H );
ent_cond = sum( ent_partial.*h0' );
<span class="comment">% display the result</span>
disp([<span class="string">'Global coding: '</span> num2str(ent_total,3), <span class="string">' bpp.'</span>]);
disp([<span class="string">'Conditional coding: '</span> num2str(ent_cond,3), <span class="string">' bpp.'</span>]);
</pre><pre class="codeoutput">Global coding: 0.938 bpp.
Conditional coding: 0.829 bpp.
</pre><p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Natural Images Statistics
% This numerical tour studies the statistics of natural images and their multiscale decomposition.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox> and 
% <../toolbox_general.zip general toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal| and 
% |toolbox_general|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');


%% Histogram of Images and Equalization
% The histogram of an image describes its gray-level repartition.

%%
% Load two images.

n = 256;
M1 = rescale( load_image('boat', n) );
M2 = rescale( load_image('lena', n) );

%%
% Display the images and its histograms.

clf;
subplot(2,2,1);
imageplot(M1);
subplot(2,2,2);
[h,t] = hist(M1(:), 60);
bar(t, h/sum(h));
axis('square');
subplot(2,2,3);
imageplot(M2);
subplot(2,2,4);
[h,t] = hist(M2(:), 60);
bar(t, h/sum(h));
axis('square');

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Histogram equalization is an orthogonal projector that maps the values
% of one signal onto the values of the other signal. This is achieved by
% assiging the sorted of ont signal to the sorted values of the other
% signla. Implement this for the two images.

exo1;

%% Statistics of the Wavelets Coefficients of Natural Images
% Although the histograms of images are flat, the histogram of their
% wavelet coefficients are usually highly picked at zero, resulting in a
% low entropy.

%%
% Load an image.

n = 256*2;
M = rescale( load_image('lena', n) );

%%
% Compute its wavelet coefficients.

Jmin = 4;
MW = perform_wavelet_transf(M,Jmin, +1);

%%
% Extract the fine horizontal details and display histograms. Take care at
% computing a centered histogram.

% extract the vertical details
MW1 = MW(1:n/2,n/2+1:n);
% compute histogram
v = max(abs(MW1(:)));
k = 20;
t = linspace(-v,v,2*k+1);
h = hist(MW1(:), t);
% display
clf;
subplot(1,2,1);
imageplot(MW1);
subplot(1,2,2);
bar(t, h/sum(h)); axis('tight');
axis('square');

%% Higher Order Statistics
% In order to analyse higher order statistics, one needs to consider couples of 
% wavelet coefficients. For instance, we can consider the joint distribution of 
% a coefficient and of one of its neighbors. The interesting quantities are the 
% joint histogram and the conditional histogram (normalized so that row sum to 1).

%%
% Compute quantized wavelet coefficients.

T = .03;
MW1q = floor(abs(MW1/T)).*sign(MW1);
nj = size(MW1,1);

%%
% Compute the neighbors coefficients.

% spacial shift
t = 2; % you can try with other values
C = reshape(MW1q([ones(1,t) 1:nj-t],:),size(MW1));

%% 
% Compute the conditional histogram.

options.normalize = 1;
[H,x,xc] = compute_conditional_histogram(MW1q,C, options);

%% 
% Display.

q = 8; % width for display
H = H((end+1)/2-q:(end+1)/2+q,(end+1)/2-q:(end+1)/2+q);
clf;
imagesc(-q:q,-q:q,max(log(H), -5)); axis image;
colormap gray(256);

%%
% Compute and display joint distribution.

options.normalize = 0;
[H,x,xc] = compute_conditional_histogram(MW1q,C, options);
H = H((end+1)/2-q:(end+1)/2+q,(end+1)/2-q:(end+1)/2+q);
% display level sets
clf;
contour(-q:q,-q:q,max(log(H), -5), 20, 'k'); axis image;
colormap gray(256);


%% Conditional coding
% Since the neighboring coefficients are typically un-correlated but
% dependant, one can use this dependancy to build a conditional coder. In
% essence, it amouts to using several coder, and coding a coefficient with the coder that
% corresponds to the neighbooring value. Here we consider 3 coder (depending on the sign of the neighbor).

%% 
% Compute the contexts of the coder, this is the sign of the neighbor.

C = sign( reshape(MW1q([1 1:nj-1],:),size(MW1)) );

%% 
% Compute the conditional histogram
[H,x,xc] = compute_conditional_histogram(MW1q,C);

%%
% Display the curve of the histogram

clf; plot(x,H, '.-');
axis([-10 10 0 max(H(:))]);
legend('sign=-1', 'sign=0', 'sign=+1');
set_graphic_sizes([], 20);

%%
% Compare the entropy with/without coder.

% global entropy (without context)
ent_total = compute_entropy(MW1q);
% compute the weighted entropy of this context coder
h0 = compute_histogram(C);
H(H==0) = 1e-9; % avoid numerical problems
ent_partial = sum( -log2(H).*H );
ent_cond = sum( ent_partial.*h0' );
% display the result
disp(['Global coding: ' num2str(ent_total,3), ' bpp.']);
disp(['Conditional coding: ' num2str(ent_cond,3), ' bpp.']);

##### SOURCE END #####
-->
   </body>
</html>