
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Anisotropic Fast Marching</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-21">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Anisotropic Fast Marching</h1>
         <introduction>
            <p>This tour explores the use of geodesic distances for anisotropic metric.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Structure Tensor Field</a></li>
               <li><a href="#16">Anisotropic Fast Marching</a></li>
               <li><a href="#23">Farthest Point Sampling</a></li>
               <li><a href="#33">Anisotropic Image Approximation</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a>, <a href="../toolbox_general.zip">general toolbox</a> and <a href="../toolbox_graph.zip">graph toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt>, <tt>toolbox_general</tt> and <tt>toolbox_graph</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
getd(<span class="string">'toolbox_graph/'</span>);
</pre><h2>Structure Tensor Field<a name="8"></a></h2>
         <p>An anisotropic metric is given through a tensfor field <tt>T</tt> which is an <tt>(n,n,2,2)</tt> array, where <tt>T(i,j,:,:)</tt> is a positive definite symmetric matrix that define the metric at pixel <tt>(i,j)</tt>.
         </p>
         <p>Here we extract the tensor field whose main eigenvector field is alligned with the direction of the texture. This can be achieved
            using the structure tensor field, which remove the sign ambiguity by tensorizing the gradient, and remove noise by filtering.
         </p>
         <p>Load an image that contains an oscillating texture.</p><pre class="codeinput">name = <span class="string">'fingerprint'</span>;
n = 150;
M = rescale(load_image(name,n));
</pre><p>Compute its gradient.</p><pre class="codeinput">options.order = 2;
G = grad(M,options);
</pre><p>Compute a rank-1 tensor with main eigenvector aligned in the direction orthogonal to the gradient.</p><pre class="codeinput">T = zeros(n,n,2,2);
T(:,:,1,1) = G(:,:,2).^2;
T(:,:,2,2) = G(:,:,1).^2;
T(:,:,1,2) = -G(:,:,1).*G(:,:,2);
T(:,:,2,1) = -G(:,:,1).*G(:,:,2);
</pre><p>Smooth the field (blur each entry).</p><pre class="codeinput">sigma = 12;
T = perform_blurring(T,sigma);
</pre><p>Compute the eigenvector and eigenvalues of the tensor field.</p><pre class="codeinput">[e1,e2,l1,l2] = perform_tensor_decomp(T);
</pre><p>Display the main orientation field.</p><pre class="codeinput">clf;
plot_vf(e1(1:10:n,1:10:n,:),M);
colormap(gray(256));
</pre><img vspace="5" hspace="5" src="index_01.png"> <h2>Anisotropic Fast Marching<a name="16"></a></h2>
         <p>One can compute geodesic distance and geodesics using an anisotropic Fast Marching propagation.</p>
         <p>Anisotropy of the tensor field.</p><pre class="codeinput">anisotropy = .1;
</pre><p>Build the Riemannian metric using the structure tensor direction.</p><pre class="codeinput">H = perform_tensor_recomp(e1,e2, ones(n),ones(n)*1/anisotropy );
</pre><p>Starting point.</p><pre class="codeinput">pstart = [n n]/4;
</pre><p>Perform the propagation.</p><pre class="codeinput">hx = 1/n; hy = 1/n;
[D, dUx, dUy, Vor, L] = fm2dAniso([hx;hy], H, pstart);
</pre><p>Display the result.</p><pre class="codeinput">clf;
subplot(1,2,1);
imageplot(M, <span class="string">'Image'</span>);
subplot(1,2,2);
hold <span class="string">on</span>;
imageplot(convert_distance_color(D), <span class="string">'Geodesic distance'</span>);
hh = plot(pstart(2),pstart(1), <span class="string">'r.'</span>);
set(hh, <span class="string">'MarkerSize'</span>,15);
axis(<span class="string">'ij'</span>);
colormap(gray(256));
</pre><img vspace="5" hspace="5" src="index_02.png"> <p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Compute the geodesic distance for several anisotropy, and for several starting points.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_03.png"> <h2>Farthest Point Sampling<a name="23"></a></h2>
         <p>It is possible to perform an anisotropic sampling of the image using a Farthest point sampling strategy.</p>
         <p>We use a highly anisotropic metric.</p><pre class="codeinput">anisotropy = .02;
H = perform_tensor_recomp(e1,e2, ones(n),ones(n)*1/anisotropy );
</pre><p>Choose the initial point.</p><pre class="codeinput">vertex = [1;1];
</pre><p>Compute the geodesic distance.</p><pre class="codeinput">[D, dUx, dUy, Vor, L] = fm2dAniso([hx;hy], H, vertex);
</pre><p>Choose the second point as the farthest point.</p><pre class="codeinput">[tmp,i] = max(D(:));
[x,y] = ind2sub([n n],i);
vertex(:,end+1) = [x;y];
</pre><p>Display distance and points.</p><pre class="codeinput">clf;
subplot(1,2,1);
hold <span class="string">on</span>;
imageplot(M, <span class="string">'Image'</span>); axis <span class="string">ij</span>;
plot(vertex(2,1), vertex(1,1), <span class="string">'r.'</span>);
plot(vertex(2,2), vertex(1,2), <span class="string">'b.'</span>);
subplot(1,2,2);
hold <span class="string">on</span>;
imageplot( convert_distance_color(D), <span class="string">'Distance'</span>); axis <span class="string">ij</span>;
plot(vertex(2,1), vertex(1,1), <span class="string">'r.'</span>);
plot(vertex(2,2), vertex(1,2), <span class="string">'b.'</span>);
colormap <span class="string">gray(256)</span>;
</pre><img vspace="5" hspace="5" src="index_04.png"> <p>Update the value of the distance map with a partial propagation from the last added point.</p><pre class="codeinput">[D1, dUx, dUy, Vor, L] = fm2dAniso([hx;hy], H, vertex);
</pre><p>Display old/new.</p><pre class="codeinput">clf;
imageplot( D, <span class="string">'Old distance'</span>, 1,2,1 );
imageplot( D1, <span class="string">'New distance'</span>, 1,2,2 );
colormap <span class="string">jet(256)</span>;
</pre><img vspace="5" hspace="5" src="index_05.png"> <p>Update.</p><pre class="codeinput">D = D1;
</pre><p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Perform farthest point sampling.
         </p><pre class="codeinput">exo2;
</pre><img vspace="5" hspace="5" src="index_06.png"> <h2>Anisotropic Image Approximation<a name="33"></a></h2>
         <p>One can combine the farthest point sampling strategy with a geodesic Delaunay triangulation to perform image approximation.</p>
         <p>Load an image.</p><pre class="codeinput">n = 256;
name = <span class="string">'peppers-bw'</span>;
M = rescale(load_image(name, n));
</pre><p><i>Exercice 3:</i> (<a href="../missing-exo/">check the solution</a>) Compute a metric <tt>H</tt> adapted to the approximation of this image.
         </p><pre class="codeinput">exo3;
</pre><p><i>Exercice 4:</i> (<a href="../missing-exo/">check the solution</a>) Perform farthest point sampling.
         </p><pre class="codeinput">exo4;
</pre><p><i>Exercice 5:</i> (<a href="../missing-exo/">check the solution</a>) Compute the geodesic Delaunay triangulation of this set of point.
         </p><pre class="codeinput">exo5;
</pre><p><i>Exercice 6:</i> (<a href="../missing-exo/">check the solution</a>) Perform image approximation using linear splines.
         </p><pre class="codeinput">exo6;
</pre><p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Anisotropic Fast Marching
% This tour explores the use of geodesic distances for anisotropic metric.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox>, 
% <../toolbox_general.zip general toolbox> and 
% <../toolbox_graph.zip graph toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal|, 
% |toolbox_general| and 
% |toolbox_graph|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');
getd('toolbox_graph/');

%% Structure Tensor Field
% An anisotropic metric is given through a tensfor field |T| which
% is an |(n,n,2,2)| array, where |T(i,j,:,:)| is a positive definite
% symmetric matrix that define the metric at pixel |(i,j)|.

%%
% Here we extract the tensor field whose main eigenvector field is alligned
% with the direction of the texture. This can be achieved using the
% structure tensor field, which remove the sign ambiguity by tensorizing
% the gradient, and remove noise by filtering.

%%
% Load an image that contains an oscillating texture.

name = 'fingerprint';
n = 150;
M = rescale(load_image(name,n));

%%
% Compute its gradient.

options.order = 2;
G = grad(M,options);

%%
% Compute a rank-1 tensor with main eigenvector aligned in the direction
% orthogonal to the gradient.

T = zeros(n,n,2,2);
T(:,:,1,1) = G(:,:,2).^2;
T(:,:,2,2) = G(:,:,1).^2;
T(:,:,1,2) = -G(:,:,1).*G(:,:,2);
T(:,:,2,1) = -G(:,:,1).*G(:,:,2);

%%
% Smooth the field (blur each entry).

sigma = 12;
T = perform_blurring(T,sigma);

%%
% Compute the eigenvector and eigenvalues of the tensor field.

[e1,e2,l1,l2] = perform_tensor_decomp(T);

%%
% Display the main orientation field.

clf;
plot_vf(e1(1:10:n,1:10:n,:),M);
colormap(gray(256));

%% Anisotropic Fast Marching
% One can compute geodesic distance and geodesics using an anisotropic Fast
% Marching propagation.

%%
% Anisotropy of the tensor field.

anisotropy = .1;

%%
% Build the Riemannian metric using the structure tensor direction.

H = perform_tensor_recomp(e1,e2, ones(n),ones(n)*1/anisotropy );

%%
% Starting point.

pstart = [n n]/4;

%%
% Perform the propagation.

hx = 1/n; hy = 1/n;
[D, dUx, dUy, Vor, L] = fm2dAniso([hx;hy], H, pstart);

%%
% Display the result.

clf;
subplot(1,2,1);
imageplot(M, 'Image');
subplot(1,2,2);
hold on;
imageplot(convert_distance_color(D), 'Geodesic distance');
hh = plot(pstart(2),pstart(1), 'r.');
set(hh, 'MarkerSize',15);
axis('ij');
colormap(gray(256));

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Compute the geodesic distance for several anisotropy, and for several
% starting points.

exo1;

%% Farthest Point Sampling
% It is possible to perform an anisotropic sampling of the image using a
% Farthest point sampling strategy.

%%
% We use a highly anisotropic metric.

anisotropy = .02;
H = perform_tensor_recomp(e1,e2, ones(n),ones(n)*1/anisotropy );
    

%%
% Choose the initial point.

vertex = [1;1];

%%
% Compute the geodesic distance.

[D, dUx, dUy, Vor, L] = fm2dAniso([hx;hy], H, vertex);

%%
% Choose the second point as the farthest point.

[tmp,i] = max(D(:));
[x,y] = ind2sub([n n],i); 
vertex(:,end+1) = [x;y];

%%
% Display distance and points.

clf;
subplot(1,2,1);
hold on;
imageplot(M, 'Image'); axis ij;
plot(vertex(2,1), vertex(1,1), 'r.');
plot(vertex(2,2), vertex(1,2), 'b.');
subplot(1,2,2);
hold on;
imageplot( convert_distance_color(D), 'Distance'); axis ij;
plot(vertex(2,1), vertex(1,1), 'r.');
plot(vertex(2,2), vertex(1,2), 'b.');
colormap gray(256);


%%
% Update the value of the distance map with a partial propagation from the last added point.

[D1, dUx, dUy, Vor, L] = fm2dAniso([hx;hy], H, vertex);

%% 
% Display old/new.

clf;
imageplot( D, 'Old distance', 1,2,1 );
imageplot( D1, 'New distance', 1,2,2 );
colormap jet(256);

%% 
% Update.

D = D1;

%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Perform farthest point sampling.

exo2;

%% Anisotropic Image Approximation
% One can combine the farthest point sampling strategy with a geodesic
% Delaunay triangulation to perform image approximation.

%%
% Load an image.

n = 256;
name = 'peppers-bw';
M = rescale(load_image(name, n));

%%
% _Exercice 3:_ (<../missing-exo/ check the solution>)
% Compute a metric |H| adapted to the approximation of this image.

exo3;

%%
% _Exercice 4:_ (<../missing-exo/ check the solution>)
% Perform farthest point sampling.

exo4;

%%
% _Exercice 5:_ (<../missing-exo/ check the solution>)
% Compute the geodesic Delaunay triangulation of this set of point.

exo5;

%%
% _Exercice 6:_ (<../missing-exo/ check the solution>)
% Perform image approximation using linear splines.

exo6;

##### SOURCE END #####
-->
   </body>
</html>