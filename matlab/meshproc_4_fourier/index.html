
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Fourier on Meshes</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-21">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Fourier on Meshes</h1>
         <introduction>
            <p>This tour explores the use of the eigenvectors of the Laplacian, for filtering and for compression.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#8">Fourier Basis on Meshes</a></li>
               <li><a href="#19">Linear Approximation over the Fourier Domain</a></li>
               <li><a href="#25">Non-linear Approximation over the Fourier Domain</a></li>
               <li><a href="#32">Spectral Mesh Compression</a></li>
            </ul>
         </div>
         <h2>Installing toolboxes and setting up the path.<a name="1"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a>, <a href="../toolbox_general.zip">general toolbox</a> and <a href="../toolbox_graph.zip">graph toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt>, <tt>toolbox_general</tt> and <tt>toolbox_graph</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
getd(<span class="string">'toolbox_graph/'</span>);
</pre><h2>Fourier Basis on Meshes<a name="8"></a></h2>
         <p>The Fourier basis are defined as the eigenvector of the Laplacian.</p>
         <p>First load a mesh.</p><pre class="codeinput">name = <span class="string">'elephant-50kv'</span>;
[vertex,faces] = read_mesh(name);
options.name = name;
n = size(vertex,2);
</pre><p>The combinatorial laplacian is a linear operator (thus a NxN matrix where N is the number of vertices). It depends only on
            the connectivity of the mesh, thus on face only.
         </p>
         <p>Compute edge list.</p><pre class="codeinput">E = [faces([1 2],:) faces([2 3],:) faces([3 1],:)];
p = size(E,2);
</pre><p>Compute the adjacency matrix.</p><pre class="codeinput">W = sparse( E(1,:), E(2,:), ones(p,1) );
W = max(W,W');
</pre><p>Compute the combinatorial Laplacian, stored as a sparse matrix.</p><pre class="codeinput">D = spdiags(sum(W)', 0, n,n);
L = D-W;
</pre><p>The eigenvector of this matrix forms an orthogonal basis of the vector space of signal of NxN values (one real value per vertex).
            Those functions are the extension of the Fourier oscillating functions to surfaces. For a small mesh (less than 1000) vertices,
            one can compute this set of vectors using the <tt>eig</tt> functions. For large meshes, one can compute only a small (e.g. 50) number of low pass eigenvectors using the sparse eigenvector
            extraction procedure, <tt>eigs</tt>.
         </p>
         <p>Compute the eigenvectors.</p><pre class="codeinput">nb = 80;
opts.disp = 0;
[U,S] = eigs(L,nb,<span class="string">'SM'</span>,opts);
S = diag(S);
</pre><p>Order the eigenvector by increasing frequencies.</p><pre class="codeinput">[S,I] = sort(S, <span class="string">'ascend'</span>);
U = real( U(:,I) );
</pre><p>Plot the eigenvalues. This corresponds to the spectrum of the triangulation. It depends only on the topology of the mesh.</p><pre class="codeinput">clf;
plot(S); axis(<span class="string">'tight'</span>);
</pre><img vspace="5" hspace="5" src="index_01.png"> <p>Display a sub-set of eigenvectors.</p><pre class="codeinput">ilist = round(linspace(3,nb, 6));
tau=2.2; <span class="comment">% saturation for display</span>
clf;
<span class="keyword">for</span> i=1:length(ilist)
    v = real(U(:,ilist(i)));
    v = clamp( v/std(v),-tau,tau );
    options.face_vertex_color = v;
    subplot(2,3,i);
    plot_mesh(vertex,faces,options);
    shading <span class="string">interp</span>; camlight; axis <span class="string">tight</span>;
    colormap <span class="string">jet(256)</span>;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_02.png"> <h2>Linear Approximation over the Fourier Domain<a name="19"></a></h2>
         <p>Linear approximation is obtained by keeping only the low frequency coefficient. This corresponds to a low pass filtering,
            since high frequency coefficients are removed.
         </p>
         <p>Compute the projection of each coordinate <tt>vertex(i,:)</tt> on the small set of <tt>nb</tt> frequencies.
         </p><pre class="codeinput">pvertex = vertex*U;
</pre><p>Display the spectrum pf.</p><pre class="codeinput">clf;
plot(pvertex'); axis(<span class="string">'tight'</span>);
legend(<span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>);
</pre><img vspace="5" hspace="5" src="index_03.png"> <p>Reconstruct the mesh.</p><pre class="codeinput">vertex1 = pvertex*U';
</pre><p>Compare before and after approximation.</p><pre class="codeinput">clf;
subplot(1,2,1);
plot_mesh(vertex,faces);
subplot(1,2,2);
plot_mesh(vertex1,faces);
</pre><img vspace="5" hspace="5" src="index_04.png"> <p><i>Exercice 1:</i> (<a href="../missing-exo/">check the solution</a>) Show the smoothed mesh for an increasing number of Fourier frequencies <tt>nb</tt>.
         </p><pre class="codeinput">exo1;
</pre><img vspace="5" hspace="5" src="index_05.png"> <h2>Non-linear Approximation over the Fourier Domain<a name="25"></a></h2>
         <p>Non-linear approximation is obtained by keeping the largest magnitude coefficients. It is more efficient than linear approximation
            since the L2 error is reduced.
         </p>
         <p>We study here the approximation on a small mesh, to be able to compute all the wavelet coefficients.</p><pre class="codeinput">name = <span class="string">'venus'</span>;
[vertex,faces] = read_mesh(name);
options.name = name;
n = size(vertex,2);
</pre><p>Compute the combinatorial laplacian operator <tt>L</tt> of the mesh.
         </p><pre class="codeinput">E = [faces([1 2],:) faces([2 3],:) faces([3 1],:)];
W = sparse( E(1,:), E(2,:), ones(size(E,2),1) );
W = max(W,W');
L = spdiags(sum(W)', 0, n,n) - W;
</pre><p>Compute the full set of eigenvector.</p><pre class="codeinput">[U,S] = eig(full(L));
S = diag(S);
[S,I] = sort(S, <span class="string">'ascend'</span>);
U = real( U(:,I) );
</pre><p>Plot the eigenvalues.</p><pre class="codeinput">clf;
plot(S); axis(<span class="string">'tight'</span>);
</pre><img vspace="5" hspace="5" src="index_06.png"> <p><i>Exercice 2:</i> (<a href="../missing-exo/">check the solution</a>) Compute a best <tt>m</tt>-term non-linear approximation whith <tt>m=.1*n</tt>, by hard thresholding the Fourier coefficients using the correct threshold. Compare with linear <tt>m</tt> term approximation (use <tt>m/3</tt> coefficient for each coordinate X/Y/Z).
         </p><pre class="codeinput">exo2;
</pre><pre class="codeoutput">Linear:     SNR=22dB
Non-linear: SNR=24.2dB
</pre><img vspace="5" hspace="5" src="index_07.png"> <p><i>Exercice 3:</i> (<a href="../missing-exo/">check the solution</a>) Compare the rate-distortion curve (log of error as a function of the log of the number of coefficients) for linear and non-linear
            approximation.
         </p><pre class="codeinput">exo3;
</pre><img vspace="5" hspace="5" src="index_08.png"> <h2>Spectral Mesh Compression<a name="32"></a></h2>
         <p>Compression is obtained by quantizing the coefficients and entropic coding the resulting integer quantized coefficients.</p>
         <p>Set the quantization level. The larger, the more aggressive the coding.</p><pre class="codeinput">T = .05;
</pre><p>Compute the interger, quantized coefficients.</p><pre class="codeinput">pvertexI = floor(abs(pvertex/T)).*sign(pvertex);
</pre><p>For decompression, we compute de-quantized values from <tt>pvertexI</tt>, which are chosen as the mid-point of each quantization bin.
         </p><pre class="codeinput">pvertexQ = sign(pvertexI) .* (abs(pvertexI)+.5) * T;
</pre><p>Reconstruct the mesh from the de-compressed coefficients.</p><pre class="codeinput">vertex1 = pvertexQ*U';
</pre><p>Display the result of decompression.</p><pre class="codeinput">clf;
subplot(1,2,1);
plot_mesh(vertex,faces);
subplot(1,2,2);
plot_mesh(vertex1,faces);
</pre><img vspace="5" hspace="5" src="index_09.png"> <p>To evaluate the number of bit needed to store <tt>pvertexI</tt> in a file, we do not use a real entropic coder (such as Huffman tree of an arithmetic coder), but rather use the lower bound
            of the entropy.
         </p>
         <p>Compute the histogram of the coefficients.</p><pre class="codeinput">t = min(pvertexI(:)):max(pvertexI(:));
h = hist( pvertexI(:), t );
h = max(h,1e-10); h = h/sum(h);
</pre><p>Display the histograms. Most of the coefficients have been quantized to 0.</p><pre class="codeinput">close; clf;
bar(t, h);
axis([-5 5 0 max(h)]);
</pre><img vspace="5" hspace="5" src="index_10.png"> <p>Compute the entropy.</p><pre class="codeinput">E = -sum( log2(h).*h );
</pre><p>The number of bit per vecter is <tt>3*E</tt> since one needs <tt>E</tt> bit in average to code an entry of <tt>pvertexI</tt>.
         </p><pre class="codeinput">disp([<span class="string">'Nbr.bits per vertex = '</span> num2str(3*E,3)]);
disp([<span class="string">'Error,          SNR = '</span> num2str(snr(vertex,vertex1),3) <span class="string">'dB'</span>]);
</pre><pre class="codeoutput">Nbr.bits per vertex = 5.18
Error,          SNR = 32.7dB
</pre><p><i>Exercice 4:</i> (<a href="../missing-exo/">check the solution</a>) Perform the compression for several quantization steps <tt>T</tt> and display the rate distortion curve showing the SNR as a function of the number of bits.
         </p><pre class="codeinput">exo4;
</pre><img vspace="5" hspace="5" src="index_11.png"> <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Fourier on Meshes
% This tour explores the use of the eigenvectors of the Laplacian, for
% filtering and for compression.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox>, 
% <../toolbox_general.zip general toolbox> and 
% <../toolbox_graph.zip graph toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal|, 
% |toolbox_general| and 
% |toolbox_graph|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');
getd('toolbox_graph/');


%% Fourier Basis on Meshes
% The Fourier basis are defined as the eigenvector of the Laplacian.

%%
% First load a mesh.

name = 'elephant-50kv';
[vertex,faces] = read_mesh(name);
options.name = name; 
n = size(vertex,2);


%%
% The combinatorial laplacian is a linear operator 
% (thus a NxN matrix where N is the number of vertices). 
% It depends only on the connectivity of the mesh, thus on face only.

%%
% Compute edge list.

E = [faces([1 2],:) faces([2 3],:) faces([3 1],:)];
p = size(E,2);

%% 
% Compute the adjacency matrix.

W = sparse( E(1,:), E(2,:), ones(p,1) );
W = max(W,W');

%%
% Compute the combinatorial Laplacian, stored as a sparse matrix.

D = spdiags(sum(W)', 0, n,n);
L = D-W;

%%
% The eigenvector of this matrix forms an orthogonal basis of the
% vector space of signal of NxN values (one real value per vertex). 
% Those functions are the extension of the Fourier oscillating functions to surfaces.
% For a small mesh (less than 1000) vertices, one can compute this set of vectors using 
% the |eig| functions. For large meshes, one can compute only a small (e.g. 50) number of 
% low pass eigenvectors using the sparse eigenvector extraction procedure,
% |eigs|.

%%
% Compute the eigenvectors.

nb = 80;
opts.disp = 0;
[U,S] = eigs(L,nb,'SM',opts);
S = diag(S);

%%
% Order the eigenvector by increasing frequencies.

[S,I] = sort(S, 'ascend');
U = real( U(:,I) );

%%
% Plot the eigenvalues.
% This corresponds to the spectrum of the triangulation. It depends only on
% the topology of the mesh.

clf;
plot(S); axis('tight');


%%
% Display a sub-set of eigenvectors.

ilist = round(linspace(3,nb, 6));
tau=2.2; % saturation for display
clf;
for i=1:length(ilist)
    v = real(U(:,ilist(i)));
    v = clamp( v/std(v),-tau,tau );
    options.face_vertex_color = v;
    subplot(2,3,i);
    plot_mesh(vertex,faces,options);
    shading interp; camlight; axis tight;
    colormap jet(256);
end

%% Linear Approximation over the Fourier Domain
% Linear approximation is obtained by keeping only the low frequency
% coefficient. This corresponds to a low pass filtering, since high
% frequency coefficients are removed.

%%
% Compute the projection of each coordinate |vertex(i,:)| on the small
% set of |nb| frequencies.

pvertex = vertex*U;

%% 
% Display the spectrum pf.

clf;
plot(pvertex'); axis('tight');
legend('X', 'Y', 'Z');

%%
% Reconstruct the mesh.

vertex1 = pvertex*U';

%%
% Compare before and after approximation.

clf;
subplot(1,2,1);
plot_mesh(vertex,faces);
subplot(1,2,2);
plot_mesh(vertex1,faces);

%%
% _Exercice 1:_ (<../missing-exo/ check the solution>)
% Show the smoothed mesh for an increasing number of Fourier frequencies |nb|.

exo1;


%% Non-linear Approximation over the Fourier Domain
% Non-linear approximation is obtained by keeping the largest magnitude coefficients.
% It is more efficient than linear approximation since the L2 error
% is reduced.

%%
% We study here the approximation on a small mesh, to be able to compute
% all the wavelet coefficients.

name = 'venus';
[vertex,faces] = read_mesh(name);
options.name = name;
n = size(vertex,2);

%% 
% Compute the combinatorial laplacian operator |L| of the mesh.

E = [faces([1 2],:) faces([2 3],:) faces([3 1],:)];
W = sparse( E(1,:), E(2,:), ones(size(E,2),1) );
W = max(W,W');
L = spdiags(sum(W)', 0, n,n) - W;

%% 
% Compute the full set of eigenvector.

[U,S] = eig(full(L));
S = diag(S);
[S,I] = sort(S, 'ascend');
U = real( U(:,I) );

%%
% Plot the eigenvalues.

clf;
plot(S); axis('tight');

%%
% _Exercice 2:_ (<../missing-exo/ check the solution>)
% Compute a best |m|-term non-linear approximation whith |m=.1*n|, by
% hard thresholding the Fourier coefficients using the correct threshold.
% Compare with linear |m| term approximation (use |m/3| coefficient for each 
% coordinate X/Y/Z).

exo2;

%%
% _Exercice 3:_ (<../missing-exo/ check the solution>)
% Compare the rate-distortion curve (log of error as a function of the
% log of the number of coefficients) for linear and non-linear approximation.

exo3;

%% Spectral Mesh Compression
% Compression is obtained by quantizing the coefficients and entropic
% coding the resulting integer quantized coefficients.

%%
% Set the quantization level. The larger, the more aggressive the coding.

T = .05;

%%
% Compute the interger, quantized coefficients.

pvertexI = floor(abs(pvertex/T)).*sign(pvertex);

%%
% For decompression, we compute de-quantized values from |pvertexI|,
% which are chosen as the mid-point of each quantization bin.

pvertexQ = sign(pvertexI) .* (abs(pvertexI)+.5) * T;

%%
% Reconstruct the mesh from the de-compressed coefficients.

vertex1 = pvertexQ*U';

%%
% Display the result of decompression.

clf;
subplot(1,2,1);
plot_mesh(vertex,faces);
subplot(1,2,2);
plot_mesh(vertex1,faces);

%%
% To evaluate the number of bit needed to store |pvertexI| in a file, 
% we do not use a real entropic coder (such as Huffman tree of an
% arithmetic coder), but rather use the lower bound of the entropy.

%%
% Compute the histogram of the coefficients.

t = min(pvertexI(:)):max(pvertexI(:));
h = hist( pvertexI(:), t );
h = max(h,1e-10); h = h/sum(h);

%%
% Display the histograms. Most of the coefficients have been quantized to
% 0.

close; clf;
bar(t, h);
axis([-5 5 0 max(h)]);

%%
% Compute the entropy.

E = -sum( log2(h).*h );

%%
% The number of bit per vecter is |3*E| since one needs |E| bit in average
% to code an entry of |pvertexI|.

disp(['Nbr.bits per vertex = ' num2str(3*E,3)]);
disp(['Error,          SNR = ' num2str(snr(vertex,vertex1),3) 'dB']);


%%
% _Exercice 4:_ (<../missing-exo/ check the solution>)
% Perform the compression for several quantization steps |T| 
% and display the rate distortion curve showing the SNR
% as a function of the number of bits.

exo4;


##### SOURCE END #####
-->
   </body>
</html>